<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>ORIENTATION × TRAINING MANUAL — Experimental Media Artifact</title>
<style>
  :root{
    --bg:#0b0d10;          /* starfield sky */
    --ink:#e9e9e9;         /* primary lines/text */
    --sub:#9aa3ad;         /* secondary grid */
    --accent:#ff4d2e;      /* nodes + interactive */
    --axis:#e7f00a;        /* nodal axis line */
    --sun:#ff7b1a;         /* sun gradient-ish */
    --earth:#8fb0ff;       /* earth fill */
    --moon:#d2c0a5;        /* moon fill */
    --panel:#11151aee;     /* control panel bg */
    --glass:#0e1116aa;     /* header blur */
    --grid-on:#2a323a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased}

  header{position:fixed;inset:0 0 auto 0;height:64px;display:flex;align-items:center;justify-content:space-between;padding:0 16px;backdrop-filter:saturate(1.2) blur(8px);background:var(--glass);border-bottom:1px solid #1d242c;z-index:5}
  .brand{display:flex;gap:12px;align-items:center}
  .brand h1{font-size:14px;letter-spacing:.18em;margin:0;font-weight:700}
  .brand .tag{font-size:11px;color:var(--sub);letter-spacing:.22em}
  .dots{width:34px;height:34px;border-radius:999px;display:grid;place-items:center;background:#1a2027;border:1px solid #2a3139}
  .dots:active{transform:scale(.97)}
  .dots i{display:block;width:3px;height:3px;background:var(--ink);border-radius:2px;box-shadow:0 -6px 0 var(--ink),0 6px 0 var(--ink)}

  main{position:fixed;inset:64px 0 0 0;display:grid;grid-template-columns:1fr;}
  #canvasWrap{position:relative}
  canvas{display:block;width:100%;height:100%;touch-action:none}

  /* Control panel */
  .panel{position:fixed;inset:auto 8px 8px 8px;background:var(--panel);border:1px solid #1e2630;border-radius:16px;padding:10px 12px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;z-index:6}
  .panel label{font-size:12px;color:var(--sub)}
  .panel .row{display:flex;gap:8px;align-items:center;flex:1 1 180px}
  select, button, input[type=range]{appearance:none;border-radius:12px;border:1px solid #2a3139;background:#0c1116;color:var(--ink);padding:8px 10px;font-size:12px}
  input[type=range]{width:120px}
  button{cursor:pointer}
  button.primary{background:var(--accent);border-color:#ff6f55;color:white}

  /* Info sheet */
  dialog{max-width:min(680px,92vw);background:#0d1116;border:1px solid #2a3139;border-radius:16px;color:var(--ink);padding:18px 16px}
  dialog::backdrop{background:#0008}
  .info h2{letter-spacing:.18em;font-size:12px;margin:0 0 10px 0;color:var(--sub)}
  .info p{font-size:13px;line-height:1.5;color:#c9d0d7}
  .info code{background:#0a0f14;border:1px solid #1f2832;padding:2px 6px;border-radius:6px}
  .info .muted{color:#9aa3ad}

  /* Desktop assist */
  @media (min-width:980px){
    main{grid-template-columns:1fr 320px}
    #canvasWrap{grid-column:1}
    .panel{right:16px;left:auto;max-width:320px}
  }
</style>
</head>
<body>
  <header>
    <div class="brand" aria-label="artifact header">
      <div>
        <div class="tag">EXPERIMENTAL MEDIA ARTIFACT</div>
        <h1>ORIENTATION · TRUE NODAL AXIS · TRAINING MANUAL</h1>
      </div>
    </div>
    <button class="dots" id="openInfo" aria-label="open info and settings"><i></i></button>
  </header>
  
  <main>
    <div id="canvasWrap">
      <canvas id="sky" aria-label="interactive media canvas"></canvas>
    </div>
  </main>

  <!-- Floating controls (mobile-first) -->
  <div class="panel" role="region" aria-label="controls">
    <div class="row">
      <label for="mode">Mode</label>
      <select id="mode">
        <option value="orientation">Orientation</option>
        <option value="manual">Training Manual (polar)</option>
      </select>
    </div>
    <div class="row">
      <label for="anim">Animate</label>
      <input id="anim" type="range" min="0" max="1" step="1" value="1"/>
      <label class="muted" id="speedLbl">on</label>
    </div>
    <div class="row">
      <label for="noise">Drift</label>
      <input id="noise" type="range" min="0" max="100" value="18" />
    </div>
    <div class="row">
      <button id="snap">Export PNG</button>
      <button id="reset">Reset</button>
      <button id="seed" class="primary">New Seed</button>
    </div>
  </div>

  <dialog id="info">
    <article class="info">
      <h2>ABOUT</h2>
      <p>
        This single‑file artifact is a live study in <em>orientation</em> and <em>training</em>:
        two views of the same dynamic system. Drag the red nodes, tug the orbits, and watch the
        <strong>True Nodal Axis</strong> re‑resolve. On touch devices, subtle haptics trigger when you cross the axis.
      </p>
      <h2>INTERACTION</h2>
      <p>
        • <strong>Drag</strong> red squares (nodes) or the planet to perturb paths.<br/>
        • <strong>Pinch/Scroll</strong> to zoom; <strong>two‑finger drag</strong> to pan.<br/>
        • <strong>Mode</strong> switches rectangular grid (Orientation) and polar manual grids.<br/>
        • <strong>Drift</strong> adds orbital noise. <strong>Export PNG</strong> saves a poster snapshot.
      </p>
      <h2>THEORY</h2>
      <p>
        The piece riffs on nodal mechanics as metaphor: systems orient around attractors; axes are
        invisible constraints that become visible through interaction. It borrows visual language from
        ephemeris charts and training manuals—the pragmatic and the poetic.
      </p>
      <p class="muted">Concept echoes by Jordan Caldwell · Design vibes by WSDIA · Implementation as code‑canvas.</p>
      <form method="dialog" style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end">
        <button>Close</button>
      </form>
    </article>
  </dialog>

<script>
(() => {
  // --- Canvas bootstrap ------------------------------------------------------
  const canvas = document.getElementById('sky');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  const S = { w: 0, h: 0 };

  function resize(){
    const r = canvas.getBoundingClientRect();
    S.w = Math.floor(r.width * DPR);
    S.h = Math.floor((window.innerHeight - 64) * DPR);
    canvas.width = S.w; canvas.height = S.h;
    canvas.style.width = r.width + 'px';
    canvas.style.height = (window.innerHeight - 64) + 'px';
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // --- World state -----------------------------------------------------------
  let seed = Math.random()*10000|0;
  const rng = mulberry(seed);
  let t = 0;
  const state = {
    mode: 'orientation',
    pan: {x:0,y:0},
    zoom: 1,
    animate: true,
    noise: 18,
    nodes: [ {x:-140,y:120}, {x:180,y:140} ], // red squares
    earth: {x:20, y:190, r:26},
    moon:  {ang:0, r:9, dist:44},
    sun:   {x:210, y:-120, r:120},
    dragging: null
  };

  // --- UI elements -----------------------------------------------------------
  const modeSel = document.getElementById('mode');
  const animRange = document.getElementById('anim');
  const speedLbl = document.getElementById('speedLbl');
  const drift = document.getElementById('noise');
  const snap = document.getElementById('snap');
  const reset = document.getElementById('reset');
  const seedBtn = document.getElementById('seed');
  const info = document.getElementById('info');
  document.getElementById('openInfo').onclick = () => info.showModal();

  modeSel.oninput = () => state.mode = modeSel.value;
  animRange.oninput = () => {
    state.animate = animRange.value === '1';
    speedLbl.textContent = state.animate? 'on':'off';
  };
  drift.oninput = () => state.noise = +drift.value;

  snap.onclick = () => exportPNG();
  reset.onclick = () => { Object.assign(state, {
    pan:{x:0,y:0}, zoom:1, nodes:[{x:-140,y:120},{x:180,y:140}], earth:{x:20,y:190,r:26}
  }); vibrate(10); };
  seedBtn.onclick = () => {seed=(Math.random()*1e6|0); setSeed(seed); vibrate([10,20,10]);};

  function setSeed(s){
    const r = mulberry(s); // temp rng
    state.sun.x = lerp(-260, 280, r());
    state.sun.y = lerp(-220, -60, r());
  }

  // --- Interaction: pan/zoom/drag -------------------------------------------
  const pointer = {x:0,y:0,down:false, id:null, lastX:0, lastY:0};
  const view = {
    toWorld: (sx,sy)=>({ x:(sx*DPR - S.w/2)/state.zoom - state.pan.x, y:(sy*DPR - S.h/2)/state.zoom - state.pan.y }),
    toScreen: (wx,wy)=>({ x:( (wx+state.pan.x)*state.zoom + S.w/2)/DPR, y:( (wy+state.pan.y)*state.zoom + S.h/2)/DPR })
  };

  canvas.addEventListener('pointerdown', (e)=>{
    pointer.down = true; pointer.id = e.pointerId; canvas.setPointerCapture(e.pointerId);
    pointer.x = e.clientX; pointer.y = e.clientY; pointer.lastX = e.clientX; pointer.lastY = e.clientY;
    const w = view.toWorld(e.clientX, e.clientY);
    // hit tests: nodes, earth, sun
    const hitNode = state.nodes.findIndex(n => dist(n.x,n.y,w.x,w.y) < 16/state.zoom);
    if(hitNode>-1){ state.dragging = {type:'node', index:hitNode, ox:w.x - state.nodes[hitNode].x, oy:w.y - state.nodes[hitNode].y}; return;}
    if(dist(state.earth.x,state.earth.y,w.x,w.y) < (state.earth.r+8)/state.zoom){ state.dragging = {type:'earth', ox:w.x-state.earth.x, oy:w.y-state.earth.y}; return;}
    if(dist(state.sun.x,state.sun.y,w.x,w.y) < (state.sun.r+24)/state.zoom){ state.dragging = {type:'sun', ox:w.x-state.sun.x, oy:w.y-state.sun.y}; return;}
    state.dragging = {type:'pan'};
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!pointer.down) return; const w = view.toWorld(e.clientX, e.clientY);
    if(state.dragging){
      if(state.dragging.type==='node'){
        const n = state.nodes[state.dragging.index];
        n.x = w.x - state.dragging.ox; n.y = w.y - state.dragging.oy;
        if(Math.abs(projectPointOnLine(n, state.nodes[1-state.dragging.index]))<4/state.zoom){ vibrate(6); }
      }else if(state.dragging.type==='earth'){
        state.earth.x = w.x - state.dragging.ox; state.earth.y = w.y - state.dragging.oy;
      }else if(state.dragging.type==='sun'){
        state.sun.x = w.x - state.dragging.ox; state.sun.y = w.y - state.dragging.oy;
      }else if(state.dragging.type==='pan'){
        state.pan.x += (e.clientX - pointer.lastX) * DPR / state.zoom;
        state.pan.y += (e.clientY - pointer.lastY) * DPR / state.zoom;
      }
    }
    pointer.lastX = e.clientX; pointer.lastY = e.clientY;
  });
  window.addEventListener('pointerup', ()=>{ pointer.down=false; state.dragging=null; });

  // Zoom (wheel + pinch)
  let lastDist=0;
  canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); zoomAt(e.deltaY<0?1.08:0.92, e.clientX, e.clientY); }, {passive:false});
  canvas.addEventListener('touchmove', (e)=>{
    if(e.touches.length===2){ e.preventDefault(); const d = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY);
      if(lastDist){ const f = d/lastDist; zoomAt(f, (e.touches[0].clientX+e.touches[1].clientX)/2, (e.touches[0].clientY+e.touches[1].clientY)/2); }
      lastDist = d;
    }
  }, {passive:false});
  window.addEventListener('touchend', ()=> lastDist=0);

  function zoomAt(f, sx, sy){
    const before = view.toWorld(sx, sy);
    state.zoom = clamp(state.zoom*f, 0.5, 3.5);
    const after = view.toWorld(sx, sy);
    state.pan.x += before.x - after.x; state.pan.y += before.y - after.y;
  }

  // --- Render loop -----------------------------------------------------------
  function frame(){
    if(state.animate) t += 0.016;
    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function draw(){
    ctx.save();
    ctx.clearRect(0,0,S.w,S.h);

    // starfield background
    starfield(ctx, S, seed);

    ctx.translate(S.w/2, S.h/2);
    ctx.scale(state.zoom, state.zoom);
    ctx.translate(state.pan.x, state.pan.y);

    // Grid type
    if(state.mode==='orientation') rectGrid(); else polarGrid();

    // Orbits + axis
    const axisA = state.nodes[0], axisB = state.nodes[1];
    line(axisA.x,axisA.y, axisB.x,axisB.y, {stroke: 'var(--ink)', alpha:.25, width:1});
    text('TRUE NODAL\nAXIS', (axisA.x+axisB.x)/2 - 44, (axisA.y+axisB.y)/2 - 10, 11, 0.18);

    // Sun
    blob(state.sun.x, state.sun.y, state.sun.r, 'var(--sun)');

    // Earth + moon
    circle(state.earth.x, state.earth.y, state.earth.r+14, {stroke:'var(--sub)', dash:[6,6], alpha:.45});
    circle(state.earth.x, state.earth.y, state.earth.r, {fill:'var(--earth)'});
    const moonAng = t*0.7;
    const mx = state.earth.x + Math.cos(moonAng)*state.moon.dist; const my = state.earth.y + Math.sin(moonAng)*state.moon.dist;
    circle(mx,my,state.moon.r,{fill:'var(--moon)'});

    // Elliptical path toward sun
    orbitPath(state.sun.x, state.sun.y, 420, 600, 0.35, 0.6);

    // Nodes (draggable)
    state.nodes.forEach(n => node(n.x, n.y));

    ctx.restore();
  }

  // --- Drawing helpers -------------------------------------------------------
  function rectGrid(){
    ctx.save();
    const sz = 80;
    ctx.strokeStyle = getCSS('--grid-on'); ctx.globalAlpha = 0.65; ctx.lineWidth = 1;
    // major
    ctx.beginPath();
    for(let x=-2000; x<=2000; x+=sz){ ctx.moveTo(x,-2000); ctx.lineTo(x,2000);} 
    for(let y=-2000; y<=2000; y+=sz){ ctx.moveTo(-2000,y); ctx.lineTo(2000,y);} 
    ctx.stroke();
    ctx.globalAlpha = 0.25; ctx.lineWidth = 1;
    ctx.beginPath();
    for(let x=-2000; x<=2000; x+=sz/5){ ctx.moveTo(x,-2000); ctx.lineTo(x,2000);} 
    for(let y=-2000; y<=2000; y+=sz/5){ ctx.moveTo(-2000,y); ctx.lineTo(2000,y);} 
    ctx.stroke();
    ctx.restore();
    label('ORIENTATION', -360, -260);
  }

  function polarGrid(){
    ctx.save();
    ctx.strokeStyle = getCSS('--grid-on'); ctx.globalAlpha = 0.65; ctx.lineWidth = 1;
    const rMax = 600; 
    for(let r=60;r<=rMax;r+=60){ circle(0,0,r,{stroke:getCSS('--grid-on'), alpha:0.5}); }
    ctx.globalAlpha = 0.32;
    for(let a=0;a<Math.PI*2;a+=Math.PI/12){ line(0,0, Math.cos(a)*rMax, Math.sin(a)*rMax, {stroke:getCSS('--grid-on'), alpha:0.5}); }
    ctx.restore();
    label('TRAINING MANUAL', -360, -260);
    // ring captions
    text('Grounding\nShedding\nBaseline\nIntegrating', -36, 12, 11, .2);
    // small black squares on baseline arc for vibes
    ctx.save();
    ctx.fillStyle = '#0f151b'; ctx.globalAlpha=0.9;
    ctx.fillRect(110,12,10,10); ctx.fillRect(160,8,10,10);
    ctx.restore();
  }

  function orbitPath(cx,cy,rx,ry,k1=.4,k2=.4){
    ctx.save();
    ctx.setLineDash([6,6]); ctx.globalAlpha = .55; ctx.strokeStyle = getCSS('--sub');
    ctx.beginPath();
    for(let a=0;a<Math.PI*2;a+=0.01){
      const n = noise2d(Math.cos(a)*k1 + t*0.08, Math.sin(a)*k2 + t*0.05) * state.noise;
      const x = cx + Math.cos(a)*(rx+n), y = cy + Math.sin(a)*(ry+n);
      if(a===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function starfield(ctx,S,seed){
    const r = mulberry(seed);
    ctx.save();
    ctx.fillStyle = '#07090c'; ctx.fillRect(0,0,S.w,S.h);
    for(let i=0;i<600;i++){
      const x = r()*S.w, y = r()*S.h; const a = r();
      ctx.fillStyle = `rgba(255,255,255,${0.15 + a*0.85})`;
      ctx.fillRect(x,y,1,1);
      if(a>0.92){ ctx.fillRect(x+1,y,1,1); }
    }
    ctx.restore();
  }

  function text(str,x,y, size=12, track=0.15){
    ctx.save(); ctx.fillStyle = getCSS('--ink'); ctx.globalAlpha = .9; ctx.font = `${size}px ui-monospace, Menlo, Consolas, monospace`;
    const lines = (str+"").split('\n');
    for(let i=0;i<lines.length;i++){
      const s = spaced(lines[i], track);
      ctx.fillText(s, x, y + i*size*1.4);
    }
    ctx.restore();
  }
  function label(str,x,y){ text(str,x,y,14, .22); }

  function node(x,y){
    ctx.save();
    ctx.fillStyle = getCSS('--accent'); ctx.globalAlpha=0.95; ctx.strokeStyle = '#ffcfbe';
    ctx.lineWidth = 1.5; ctx.beginPath(); ctx.rect(x-8,y-8,16,16); ctx.fill(); ctx.stroke();
    ctx.restore();
  }
  function circle(x,y,r,opt={}){
    ctx.save();
    if(opt.alpha!=null) ctx.globalAlpha = opt.alpha;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
    if(opt.fill){ ctx.fillStyle = opt.fill; ctx.fill(); }
    if(opt.stroke||opt.stroke===undefined){ ctx.strokeStyle = opt.stroke||getCSS('--sub'); if(opt.dash) ctx.setLineDash(opt.dash); ctx.stroke(); }
    ctx.restore();
  }
  function blob(x,y,r, css){
    const g = ctx.createRadialGradient(x-0.3*r,y-0.3*r, r*0.2, x,y,r);
    const c = getCSS('--sun');
    g.addColorStop(0,'#ffd36a'); g.addColorStop(1,c);
    ctx.save(); ctx.globalAlpha=0.95; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
    circle(x,y, r*0.18, {fill:'#ffe77a', stroke:'#ffefc0', alpha:0.9});
  }
  function line(x1,y1,x2,y2,opt={}){
    ctx.save(); ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    if(opt.dash) ctx.setLineDash(opt.dash);
    ctx.strokeStyle = opt.stroke? getCSSfromAny(opt.stroke): getCSS('--sub');
    ctx.globalAlpha = opt.alpha ?? 1; ctx.lineWidth = opt.width ?? 1; ctx.stroke(); ctx.restore();
  }

  // --- Utilities -------------------------------------------------------------
  function exportPNG(){
    const a = document.createElement('a'); a.download = `artifact_${Date.now()}.png`;
    a.href = canvas.toDataURL('image/png'); a.click();
  }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1,y2-y1); }
  function spaced(s,track){ return s.split('').join(' '.repeat(Math.max(0,Math.floor(track*10)))); }
  function mulberry(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
  function noise2d(x,y){ // tiny value noise
    const s = Math.sin(x*12.9898 + y*78.233 + seed) * 43758.5453; return s - Math.floor(s);
  }
  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function getCSSfromAny(v){ return (v?.startsWith('var('))? getCSS(v.slice(4,-1)) : v; }
  function vibrate(pattern){ if('vibrate' in navigator) try{ navigator.vibrate(pattern); }catch{} }
  // perpendicular distance of point p from axis AB (rough check)
  function projectPointOnLine(p, q){ // signed distance
    const A = state.nodes[0], B = state.nodes[1];
    const nx = B.y - A.y, ny = -(B.x - A.x); // normal
    const len = Math.hypot(nx,ny) || 1; const d = ((p.x - A.x)*nx + (p.y - A.y)*ny)/len; return d; 
  }
})();
</script>
</body>
</html>