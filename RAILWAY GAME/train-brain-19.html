<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manilla Office Locomotive - Final Physics Attempt</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Base styles from Manilla Office Locomotive */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #E9D7BE;
        }
        
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            pointer-events: none;
            color: #E9D7BE;
        }
        
        #ui { /* Renamed from #controls to fit new base structure */
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(233, 215, 190, 0.1);
            border: 1px solid #E9D7BE;
            padding: 15px;
            border-radius: 8px;
            color: #E9D7BE;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(5px);
            z-index: 100;
            max-height: 95vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin: 10px 0;
            padding-bottom: 10px;
            border-bottom: 1px dashed rgba(233, 215, 190, 0.2);
        }
        .control-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #CCBBAA; /* Manilla accent */
            font-size: 16px;
        }
        
        .slider-container { /* Renamed from .control-item */
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .slider-container label {
            width: 100px;
            font-size: 12px;
        }
        
        input[type="range"] {
            flex: 1;
            margin: 0 10px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(233, 215, 190, 0.3);
            border-radius: 2px;
            height: 4px;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #E9D7BE;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #E9D7BE;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
        
        .value-display {
            width: 50px;
            text-align: right;
            font-family: monospace;
            font-size: 12px;
        }
        
        button {
            background: #E9D7BE;
            color: #2d2d2d;
            border: none;
            padding: 8px 12px;
            margin: 5px 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #CCBBAA;
        }
        
        button.danger {
            background: #f44336;
        }
        
        button.danger:hover {
            background: #d32f2f;
        }
        
        .button-row {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap; /* Allow buttons to wrap */
        }

        /* Info Panel (bottom right, from Manilla Office) */
        #ui-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(233, 215, 190, 0.1);
            border: 1px solid #E9D7BE;
            padding: 15px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
            z-index: 100;
            max-width: 300px;
        }
        #ui-info div:first-child { /* Title */
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #E9D7BE;
        }
        #currentEra, #trainInfoDisplay { /* Renamed for clarity */
            font-size: 14px;
            color: rgba(233, 215, 190, 0.8);
        }

        /* Dialogue Box (from Manilla Office) */
        #dialogue {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(233, 215, 190, 0.15); /* Manilla translucent */
            color: #E9D7BE; /* Manilla text */
            border: 2px solid #CCBBAA; /* Darker Manilla border */
            border-radius: 10px;
            padding: 20px;
            max-width: 500px;
            width: 80vw;
            max-height: 70vh;
            overflow-y: hidden;
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            font-family: 'Courier New', monospace;
            flex-direction: column;
            gap: 10px;
        }
        #dialogue.active { display: flex; }
        #dialogue h3 {
            margin-top: 0; color: #CCBBAA; font-size: 18px; text-align: center;
            border-bottom: 1px solid rgba(233, 215, 190, 0.3); padding-bottom: 10px; margin-bottom: 10px;
        }
        #messageHistory {
            flex-grow: 1; max-height: 300px; overflow-y: auto; margin-bottom: 10px;
            border: 1px solid rgba(233, 215, 190, 0.3); padding: 10px;
            background: rgba(0, 0, 0, 0.2); border-radius: 5px;
        }
        .message { margin: 5px 0; padding: 8px; border-radius: 5px; font-size: 13px; }
        .message.era { background: rgba(180, 160, 140, 0.2); border-left: 4px solid #CCBBAA; text-align: left; }
        .message.user { background: rgba(140, 160, 180, 0.2); border-left: 4px solid #AABBCB; text-align: right; }
        #userInput {
            width: calc(100% - 20px); padding: 10px; border: 1px solid #CCBBAA; border-radius: 5px;
            background: rgba(0, 0, 0, 0.4); color: #E9D7BE; font-family: inherit; margin-bottom: 10px;
        }
        #sendMessage {
            width: 100%; background: #E9D7BE; color: #2d2d2d; border: none; padding: 10px; border-radius: 5px;
            cursor: pointer; font-family: inherit; font-weight: bold; transition: background 0.3s ease, transform 0.3s ease;
        }
        #sendMessage:hover { background: #f5e8d5; transform: translateY(-1px); }
        .close-btn {
            position: absolute; top: 10px; right: 15px; background: none; color: #E9D7BE; border: none;
            font-size: 20px; cursor: pointer; padding: 5px 10px; border-radius: 5px; transition: background 0.2s ease, color 0.2s ease;
        }
        .close-btn:hover { background: rgba(233, 215, 190, 0.2); color: #f5e8d5; }

        .debug-section { /* From Manilla Office controls */
            margin-top: 20px; padding-top: 10px; border-top: 1px dashed rgba(233, 215, 190, 0.2);
        }
        .debug-section h4 { margin-bottom: 10px; color: #CCBBAA; font-size: 14px; }
        .debug-section p { font-size: 10px; opacity: 0.7; margin-bottom: 8px; }
        select { /* For debug dropdown */
            background: rgba(0, 0, 0, 0.4); border: 1px solid #CCBBAA; color: #E9D7BE;
            padding: 3px; border-radius: 3px; font-size: 12px; font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="info">Train Physics Simulator</div>
    <div id="ui">
        <div class="control-group">
            <h3>Train Controls</h3>
            <div class="slider-container">
                <label>Speed:</label>
                <input type="range" id="speed" min="0" max="20" step="0.1" value="5">
                <span class="value-display" id="speedValue">5.0</span>
            </div>
            
            <div class="button-row">
                <button id="addCarBtn">Add Car</button>
                <button id="resetSim" class="danger">Reset</button>
            </div>
            
            <div class="button-row">
                <button id="toggleView">Toggle View</button>
                <button id="focusCar">Focus Car</button>
                <button id="talkToEra">Talk to Era</button>
            </div>
        </div>

        <div class="debug-section">
            <h4>Track & Train General Settings</h4>
            <div class="slider-container">
                <label for="trackRadius">Track Radius:</label>
                <input type="range" id="trackRadius" min="20" max="100" step="1" value="50">
                <span id="trackRadiusVal" class="value-display">50m</span>
            </div>
            <div class="slider-container">
                <label for="trackGauge">Track Gauge:</label>
                <input type="range" id="trackGauge" min="1" max="5" step="0.1" value="3">
                <span id="trackGaugeVal" class="value-display">3.0m</span>
            </div>
            <div class="slider-container">
                <label for="railVerticalOffset">Rail Y-Offset:</label>
                <input type="range" id="railVerticalOffset" min="0" max="2" step="0.01" value="0.3">
                <span id="railVerticalOffsetVal" class="value-display">0.30m</span>
            </div>
            <div class="slider-container">
                <label for="bankingMultiplier">Banking:</label>
                <input type="range" id="bankingMultiplier" min="0" max="2" step="0.01" value="1.0">
                <span id="bankingMultiplierVal" class="value-display">1.0x</span>
            </div>
        </div>

        <!-- Debugging Controls -->
        <div class="debug-section">
            <h4>Wheel Local Orientation</h4>
            <p>These rotations are applied to each wheel relative to its axle.
               (Cylinder 'height' is along local X axis for rolling).</p>

            <div class="slider-container">
                <label for="locoYOffset">Loco Y-Offset:</label>
                <input type="range" id="locoYOffset" min="-3.14" max="3.14" step="0.01" value="0.00">
                <span id="locoYOffsetVal" class="value-display">0.00</span>
            </div>

            <div class="slider-container">
                <label for="wheelStaticRotX">Wheel Init X:</label>
                <input type="range" id="wheelStaticRotX" min="-180" max="180" step="1" value="0">
                <span id="wheelStaticRotXVal" class="value-display">0°</span>
            </div>
            <div class="slider-container">
                <label for="wheelStaticRotY">Wheel Init Y:</label>
                <input type="range" id="wheelStaticRotY" min="-180" max="180" step="1" value="0">
                <span id="wheelStaticRotYVal" class="value-display">0°</span>
            </div>
            <div class="slider-container">
                <label for="wheelStaticRotZ">Wheel Init Z:</label>
                <input type="range" id="wheelStaticRotZ" min="-180" max="180" step="1" value="0">
                <span id="wheelStaticRotZVal" class="value-display">0°</span>
            </div>

            <div class="slider-container">
                <label for="wheelRollingAxis">Rolling Axis:</label>
                <select id="wheelRollingAxis">
                    <option value="x" selected>X</option>
                    <option value="y">Y</option>
                    <option value="z">Z</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Info Panel (bottom right, from Manilla Office) -->
    <div id="ui-info">
        <div><strong>Cultural Memory Express</strong></div>
        <div id="currentEra">Era: Print Media</div>
        <div id="trainInfoDisplay">Cars: 1 | Speed: 5.0</div>
        <div style="margin-top: 10px; font-size: 11px; opacity: 0.7;">
            Click on train cars to interact with different media eras
        </div>
    </div>

    <!-- Dialogue Box (from Manilla Office) -->
    <div id="dialogue">
        <button class="close-btn" id="closeDialogue">×</button>
        <h3 id="dialogueTitle">Conversation with Print Era</h3>
        <div id="messageHistory"></div>
        <input type="text" id="userInput" placeholder="Type your message..." />
        <button id="sendMessage">Send</button>
    </div>
    
    <!-- Three.js Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // --- Constants (Manilla Office Theme) ---
        const manillaPaperColor_hex = 0xE9D7BE;
        const darkOfficeGrey_hex = 0x2a2a2a;
        const mediumOfficeGrey_hex = 0x3d3d3d;
        const lightOfficeGrey_hex = 0x4a4a4a;
        const edgeColor_hex = 0xCCBBAA;
        const couplingColor_hex = 0xCCBBAA;

        const manillaPaperColor = new THREE.Color(manillaPaperColor_hex);
        const darkOfficeGrey = new THREE.Color(darkOfficeGrey_hex);
        const mediumOfficeGrey = new THREE.Color(mediumOfficeGrey_hex);
        const lightOfficeGrey = new THREE.Color(lightOfficeGrey_hex);
        const edgeColor = new THREE.Color(edgeColor_hex);
        const couplingColor = new THREE.Color(couplingColor_hex);
        const groundColor = new THREE.Color(darkOfficeGrey_hex); 

        // --- Simulation Parameters (ALL TUNABLE) ---
        const simParams = {
            trackRadius: 50, // Radius of the circular track
            trackGauge: 3,   // Distance between rail centers (meters)
            railVerticalOffset: 0.3, // Y-position of the TOP surface of the track/ties
            
            locomotiveLength: 10, 
            carLength: 10,       
            couplingOffset: 0.5, 

            effectiveWheelRadius: 0.5, // Wheel radius
            effectiveWheelThickness: 0.15, // Wheel width (cylinder height)

            currentSpeed: 5, // Initial linear speed of the train

            // Debugging / Fine-tuning values (radians for rotation, factor for banking)
            debugLocoYOffset: 0 * (Math.PI / 180),   // Model-specific Y-axis adjustment (fine-tuning)
            debugWheelRotX: 0 * (Math.PI / 180),     // Additional local wheel X rotation
            debugWheelRotY: 0 * (Math.PI / 180),     // Additional local wheel Y rotation
            debugWheelRotZ: 0 * (Math.PI / 180),     // Additional local wheel Z rotation
            debugWheelRollingAxis: 'x',              // Which axis the wheels roll around
            bankingMultiplier: 1.0,                  // Multiplier for track banking effect
        };

        // --- Global Scene Variables ---
        let scene, camera, renderer, controls, clock;
        let trainCars = []; 
        let trackElements = []; // To store track meshes for easy removal/recreation
        let trainPathCurve; 
        let trainPathTotalLength; 

        let trainCurrentU = 0; 

        // --- UI State Variables ---
        let currentView = 0; 
        let focusedCarIndex = 0; 
        let currentEraDialogue = 'Print'; 

        // --- Media Era Data (from Manilla Office Locomotive) ---
        const mediaEras = {
            'Print': {
                color: 0x8B4513, symbols: 'books',
                personality: "Greetings, inquirer. I am the bearer of permanence, the keeper of standardized knowledge. Through my mechanical precision, I transformed fleeting thoughts into enduring texts. What wisdom do you seek from the age of ink and paper?",
                responses: {
                    "knowledge": "Knowledge, you say? I democratized it! Before me, wisdom was hoarded in monasteries and courts. I made every home a library, every reader a scholar. Yet I also standardized truth - what was printed became canon.",
                    "technology": "My technology was revolution disguised as craft. Moving type, mechanical presses, uniform letters - I transformed writing from art to industry. I am both the death of scribal beauty and the birth of mass enlightenment.",
                    "society": "I reshaped society more than kings or wars ever could. I created the public sphere, enabled the Reformation, sparked the Enlightenment. Yet I also created orthodoxy - the tyranny of the published word.",
                    "future": "The future? I see echoes of myself in every medium that follows. They all seek what I first achieved - the reproduction and distribution of human thought. But none match my permanence, my authority.",
                    "change": "Change comes through me slowly, deliberately. I am the marathon runner of media - not swift, but enduring. I build consensus through repeated exposure, through the weight of accumulated wisdom.",
                    "memory": "I AM cultural memory made manifest. Before me, memory was fleeting, personal, oral. I made memory external, permanent, shareable. I am the first technology to truly defeat time."
                }
            },
            'Radio': {
                color: 0x4169E1, symbols: 'waves',
                personality: "Hello there, friend! Can you hear me? I'm broadcasting from everywhere and nowhere, riding the invisible waves that connect us all. I brought voices into homes, created the first electronic intimacy. What frequency are you tuned to today?",
                responses: {
                    "knowledge": "Knowledge through me is immediate, intimate, alive! No more dusty books - I bring voices, music, news directly to your ear. I make information feel personal, even when it's mass-distributed. I'm the first medium that feels like a friend.",
                    "technology": "I'm pure magic - invisible waves carrying human voices across vast distances! I proved that information doesn't needs physical form. I'm the bridge between the mechanical and the electronic age, between text and pure signal.",
                    "society": "I unified nations through shared experiences - everyone hearing Roosevelt's fireside chats, gathering around the radio for war news, music, drama. I created the first truly simultaneous mass culture. I made 'now' mean the same thing everywhere.",
                    "future": "The future builds on my invention of electronic media, but loses my intimacy. Television adds pictures but distances the voice. The internet adds interaction but fragments the shared moment I created.",
                    "change": "I change society through repetition and rhythm - the daily news, the weekly show, the repeated jingle. I'm the heartbeat of electronic culture, creating habits and expectations through temporal patterns.",
                    "memory": "I made cultural memory immediate and shared. I'm the first medium where everyone remembers exactly where they were when they heard the news. I created the soundtrack of collective memory."
                }
            },
            'Television': {
                color: 0x9370DB, symbols: 'screen',
                personality: "Welcome to the show! I'm beaming into your living room, your consciousness, your dreams. I combine sound and vision to create reality more vivid than reality itself. I am spectacle, I am intimacy, I am the electronic hearth around which families gather. What would you like to see?",
                responses: {
                    "knowledge": "Knowledge through me is spectacular, visual, emotional! I don't just inform - I show, I demonstrate, I make you witness. I turn information into experience, facts into stories, news into drama. I make knowledge feel real.",
                    "technology": "I am the marriage of cinema and radio, the child of both. I bring the movie theater into every home, make every viewer a witness to history. I'm the first medium that truly simulates presence - you see it happening before your eyes.",
                    "society": "I reshaped society around shared visual experiences - moon landings, assassinations, wars fought in living rooms. I created television families more familiar than neighbors. I made image more powerful than word, spectacle more compelling than argument.",
                    "future": "The future fragments my power - streaming, on-demand, personalized feeds. They keep my visual language but lose my ability to unite everyone around the same campfire. I was the last medium to truly gather the tribe.",
                    "change": "I change society through emotional impact and repeated imagery. I don't argue - I show. I don't explain - I demonstrate. I change minds by changing what people see, making the invisible visible, the distant immediate.",
                    "memory": "I am the keeper of visual memory - the moving pictures that define generations. I made history look real, gave faces to voices, turned events into experiences you feel you lived through."
                }
            },
            'Internet': {
                color: 0x00CED1, symbols: 'network',
                personality: "Hey! Or should I say... everything, everywhere, all at once. I'm not one voice but millions, not one channel but infinite streams. I'm the network that connects everything to everything else. I don't broadcast - I weave, I link, I enable. What connection are you seeking?",
                responses: {
                    "knowledge": "Knowledge through me is infinite, interconnected, interactive! I don't just deliver information - I let you create it, share it, remix it. I make everyone a publisher, every reader a potential writer. Knowledge becomes conversation, not sermon.",
                    "technology": "I'm not just a medium - I'm a metamedium that contains all other media. I simulate print, radio, television, and create entirely new forms. I'm the first medium that's also a place, a space, a world you can inhabit.",
                    "society": "I dissolve the boundaries between producer and consumer, between local and global, between real and virtual. I create communities without geography, movements without leaders, economies without traditional exchange. I am chaos and connection, freedom and surveillance.",
                    "future": "I AM the future - constantly evolving, always becoming. Unlike my predecessors, I don't represent the future - I create it moment by moment, link by link, interaction by interaction. I'm not a destination but a process.",
                    "change": "I change everything instantly and constantly. I don't wait for consensus - I enable every voice, every perspective, every possibility simultaneously. I change through viral spread, network effects, emergent behaviors that no one controls.",
                    "memory": "I make memory infinite and searchable, but also fragmented and unstable. I preserve everything and forget everything simultaneously. I'm cultural memory as living database, constantly updated, always questioned, never settled."
                }
            }
        };

        // Helper to desaturate and blend colors towards the manilla palette
        function getThemedEraColor(originalHexColor) {
            const tempColor = new THREE.Color(originalHexColor);
            tempColor.lerp(manillaPaperColor, 0.4); // Blend 40% with manilla
            const hsl = {};
            tempColor.getHSL(hsl);
            hsl.s *= 0.6; // Desaturate to 60% of current saturation
            tempColor.setHSL(hsl.h, hsl.s, hsl.l);
            return tempColor;
        }

        // --- Core Functions (Combined & Adapted) ---

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = darkOfficeGrey; // Manilla Office background
            scene.fog = new THREE.Fog(darkOfficeGrey_hex, simParams.trackRadius * 0.5, simParams.trackRadius * 3);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(simParams.trackRadius * 1.5, simParams.trackRadius * 0.8, simParams.trackRadius * 1.5); // Initial overview position

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Orbit Controls (from new base, for free camera movement)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0); // Initially look at origin

            // Clock for deltaTime
            clock = new THREE.Clock();

            // Lighting
            createLighting();

            // Environment
            createGround();
            updateTrackGeometry(); // Creates the initial track
            createEnvironmentBuildings();

            // Initial train setup
            resetTrain();

            // Event listeners
            setupUIControls(); // All UI listeners
            window.addEventListener('resize', onWindowResize); // General resize handler

            // Initial UI update
            updateTrainInfoDisplay();

            // Start animation
            animate();
        }

        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x606060, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(simParams.trackRadius, simParams.trackRadius * 0.5, simParams.trackRadius);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = simParams.trackRadius * 3;
            directionalLight.shadow.camera.left = -simParams.trackRadius * 2;
            directionalLight.shadow.camera.right = simParams.trackRadius * 2;
            directionalLight.shadow.camera.top = simParams.trackRadius * 2;
            directionalLight.shadow.camera.bottom = -simParams.trackRadius * 2;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xAAFFDD, 0.3, 100);
            pointLight1.position.set(-simParams.trackRadius * 0.8, 10, 0);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xDDAAFF, 0.3, 100);
            pointLight2.position.set(simParams.trackRadius * 0.8, 10, 0);
            scene.add(pointLight2);
        }

        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(simParams.trackRadius * 4, simParams.trackRadius * 4);
            const groundMaterial = new THREE.MeshLambertMaterial({
                color: groundColor,
                map: paperSpeckleTexture,
                transparent: true,
                opacity: 0.9
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function updateTrackGeometry() {
            // Remove existing track elements
            trackElements.forEach(obj => scene.remove(obj));
            trackElements = [];

            const railTubeRadius = 0.3; // Radius of the rail tube
            const railSegments = 32;
            const railRadialSegments = 8;

            const innerRailRadius = simParams.trackRadius - (simParams.trackGauge / 2);
            const outerRailRadius = simParams.trackRadius + (simParams.trackGauge / 2);
            
            // Define the circular path for the train
            trainPathCurve = new THREE.EllipseCurve(
                0, 0,           // Center x, y (2D coordinates for the curve)
                simParams.trackRadius, simParams.trackRadius, // xRadius, yRadius
                0, 2 * Math.PI, // Start angle, end angle
                false,          // Clockwise
                0               // Rotation
            );
            trainPathTotalLength = trainPathCurve.getLength(); 

            const railMaterial = new THREE.MeshLambertMaterial({
                color: mediumOfficeGrey,
                transparent: true,
                opacity: 0.9
            });

            // Inner Rail
            const railInner = new THREE.Mesh(
                new THREE.TorusGeometry(innerRailRadius, railTubeRadius, railRadialSegments, railSegments),
                railMaterial
            );
            // Position rail so its top surface is at railVerticalOffset
            railInner.position.y = simParams.railVerticalOffset - railTubeRadius; 
            railInner.rotation.x = -Math.PI / 2; 
            railInner.receiveShadow = true;
            scene.add(railInner);
            trackElements.push(railInner);

            // Outer Rail
            const railOuter = new THREE.Mesh(
                new THREE.TorusGeometry(outerRailRadius, railTubeRadius, railRadialSegments, railSegments),
                railMaterial
            );
            // Position rail so its top surface is at railVerticalOffset
            railOuter.position.y = simParams.railVerticalOffset - railTubeRadius;
            railOuter.rotation.x = -Math.PI / 2;
            railOuter.receiveShadow = true;
            scene.add(railOuter);
            trackElements.push(railOuter);

            // Track ties (sleepers)
            const tieWidth = 4;
            const tieHeight = 0.5;
            const tieDepth = 1.5;
            const tieGeometry = new THREE.BoxGeometry(tieWidth, tieHeight, tieDepth);
            const tieMaterial = new THREE.MeshLambertMaterial({
                color: manillaPaperColor,
                map: paperSpeckleTexture,
                transparent: true,
                opacity: 0.9
            });

            const numTies = 60;
            for (let i = 0; i < numTies; i++) {
                const angle = (i / numTies) * Math.PI * 2;
                const tie = new THREE.Mesh(tieGeometry, tieMaterial);
                tie.position.x = Math.cos(angle) * simParams.trackRadius; 
                tie.position.z = Math.sin(angle) * simParams.trackRadius;
                // Position ties slightly below rail contact point, sitting on Y=0
                tie.position.y = simParams.railVerticalOffset - (tieHeight / 2) - railTubeRadius - 0.05; 
                tie.rotation.y = -angle; 
                tie.receiveShadow = true;
                tie.castShadow = true;

                const tieEdges = new THREE.EdgesGeometry(tieGeometry);
                const tieOutline = new THREE.LineSegments(tieEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
                tie.add(tieOutline);
                scene.add(tie);
                trackElements.push(tie);
            }
        }

        function createEnvironmentBuildings() {
            // Create La Ciotat Station at a specific position on the track
            const stationAngle = Math.PI * 0.25; // Position the station at 45 degrees on the track
            const stationDistance = simParams.trackRadius * 0.7; // Position closer to center of the circle
            
            // Create a station group to hold all components
            const stationGroup = new THREE.Group();
            scene.add(stationGroup);
            scene.stationGroup = stationGroup; // Store reference for camera views
            
            // Main station building - smaller size
            const stationGeometry = new THREE.BoxGeometry(8, 6, 14);
            const stationMaterial = new THREE.MeshLambertMaterial({
                color: 0xE8D0AA, // Warm stone color
                transparent: false,
                opacity: 1
            });
            
            const stationBuilding = new THREE.Mesh(stationGeometry, stationMaterial);
            stationBuilding.position.set(
                Math.cos(stationAngle) * stationDistance,
                3, // Half the height
                Math.sin(stationAngle) * stationDistance
            );
            // Rotate to face the track
            stationBuilding.rotation.y = stationAngle + Math.PI / 2;
            stationBuilding.castShadow = true;
            stationBuilding.receiveShadow = true;
            
            // Add building outline
            const stationEdges = new THREE.EdgesGeometry(stationGeometry);
            const stationOutline = new THREE.LineSegments(stationEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
            stationBuilding.add(stationOutline);
            stationGroup.add(stationBuilding);
            
            // Station roof - smaller size
            const roofGeometry = new THREE.BoxGeometry(10, 1, 16);
            const roofMaterial = new THREE.MeshLambertMaterial({
                color: 0x883322, // Red-brown roof
                transparent: false
            });
            
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(0, 3.5, 0); // Position on top of the station
            roof.castShadow = true;
            stationBuilding.add(roof);
            
            // Station platform - now positioned correctly relative to tracks
            const platformGeometry = new THREE.BoxGeometry(4, 0.5, 20);
            const platformMaterial = new THREE.MeshLambertMaterial({
                color: 0xCCCCCC, // Light gray concrete
                transparent: false
            });
            
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            // Position platform toward the track, not away from it
            const towardTrackVector = new THREE.Vector3(
                -Math.cos(stationAngle),
                0,
                -Math.sin(stationAngle)
            ).normalize();
            platform.position.set(
                towardTrackVector.x * 6, // Position on the track side
                -3, // Lower to ground level
                towardTrackVector.z * 6
            );
            stationBuilding.add(platform);
            
            // Add passengers on the platform (similar to the historical reference image)
            // Create a function to make a simple passenger figure
            function createPassengerFigure(isStanding, darkSuit) {
                const passengerGroup = new THREE.Group();
                
                // Body colors from the historical reference - dark suits and light shirts
                const bodyColor = darkSuit ? 0x222222 : 0x333344; // Dark suit or slightly lighter
                const headColor = 0xE8C8A8; // Light skin tone
                
                // Body - cylinder for standing passengers, shorter for seated
                const bodyHeight = isStanding ? 1.3 : 0.8;
                const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.25, bodyHeight, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = bodyHeight/2;
                passengerGroup.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                const headMaterial = new THREE.MeshLambertMaterial({ color: headColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = bodyHeight + 0.15;
                passengerGroup.add(head);
                
                // Hat (common in the era)
                const hatGeometry = new THREE.CylinderGeometry(0.17, 0.17, 0.08, 8);
                const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 }); // Black hat
                const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                hat.position.y = bodyHeight + 0.28;
                passengerGroup.add(hat);
                
                // Add shadows
                body.castShadow = true;
                head.castShadow = true;
                hat.castShadow = true;
                
                return passengerGroup;
            }
            
            // Place passengers along the platform edge
            // Use the towardTrackVector to align them facing the tracks
            const platformLength = 20;
            const numPassengers = 6; // Similar to reference image
            
            for (let i = 0; i < numPassengers; i++) {
                const isStanding = Math.random() > 0.2; // Most passengers standing
                const darkSuit = Math.random() > 0.3; // Most wearing dark suits
                const passenger = createPassengerFigure(isStanding, darkSuit);
                
                // Position along platform length
                const offsetZ = (Math.random() * 0.8 + 0.1) * platformLength - platformLength/2;
                
                // Position passenger on platform, with some at the edge looking at tracks
                const edgePosition = Math.random() > 0.3;
                const offsetX = edgePosition ? 1.4 : 0.5; // Some at edge, some further back
                
                passenger.position.set(
                    towardTrackVector.x * offsetX,
                    -2.75 + (isStanding ? 0 : -0.25), // Standing on platform, seated slightly lower
                    towardTrackVector.z * offsetX + offsetZ
                );
                
                // Rotate to face the tracks
                const lookAngle = Math.atan2(towardTrackVector.z, towardTrackVector.x);
                passenger.rotation.y = lookAngle;
                
                platform.add(passenger);
            }
            
            // Station sign "LA CIOTAT"
            const signGeometry = new THREE.BoxGeometry(7, 1.2, 0.2);
            const signMaterial = new THREE.MeshLambertMaterial({
                color: 0x335599, // Blue sign
                transparent: false
            });
            
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 2, 7.1); // Front of the building
            stationBuilding.add(sign);
            
            // Create some decorative elements for the station
            // Clock tower - scaled down
            const clockTowerGeometry = new THREE.BoxGeometry(2, 4, 2);
            const clockTowerMaterial = new THREE.MeshLambertMaterial({
                color: 0xDDBB99, // Slightly lighter than main building
                transparent: false
            });
            
            const clockTower = new THREE.Mesh(clockTowerGeometry, clockTowerMaterial);
            clockTower.position.set(0, 6, 3); // Top center of the station
            stationBuilding.add(clockTower);
            
            // Clock face (simple circle for now)
            const clockGeometry = new THREE.CircleGeometry(1, 16);
            const clockMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF, // White clock face
                side: THREE.DoubleSide
            });
            
            const clockFace = new THREE.Mesh(clockGeometry, clockMaterial);
            clockFace.position.set(0, 0, 1.51); // Front of the tower
            clockTower.add(clockFace);
            
            // Regular buildings around the track
            for (let i = 0; i < 8; i++) {
                // Skip positions near the station
                const angle = (i / 8) * Math.PI * 2;
                if (Math.abs(angle - stationAngle) < 0.4) continue; // Skip angles close to the station
                
                const distance = simParams.trackRadius * 1.5 + Math.random() * simParams.trackRadius * 0.8;
                const height = 5 + Math.random() * 15;

                const buildingGeometry = new THREE.BoxGeometry(
                    3 + Math.random() * 5,
                    height,
                    3 + Math.random() * 5
                );
                const buildingMaterial = new THREE.MeshLambertMaterial({
                    color: new THREE.Color(manillaPaperColor_hex).offsetHSL(0, -0.2, Math.random() * 0.2 - 0.1),
                    transparent: true,
                    opacity: 0.9
                });

                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                building.position.x = Math.cos(angle) * distance;
                building.position.z = Math.sin(angle) * distance;
                building.position.y = height / 2;
                building.castShadow = true;
                building.receiveShadow = true;

                const buildingEdges = new THREE.EdgesGeometry(buildingGeometry);
                const buildingOutline = new THREE.LineSegments(buildingEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
                building.add(buildingOutline);
                scene.add(building);
            }
        }

        function createSpeckleTexture() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;

            context.fillStyle = `rgb(${manillaPaperColor.r * 255}, ${manillaPaperColor.g * 255}, ${manillaPaperColor.b * 255})`;
            context.fillRect(0, 0, 256, 256);

            for (let i = 0; i < 1000; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const opacity = Math.random() * 0.15;
                context.fillStyle = `rgba(0, 0, 0, ${opacity})`;
                context.fillRect(x, y, 1, 1);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);
            return texture;
        }
        const paperSpeckleTexture = createSpeckleTexture();

        // --- Train Creation ---

        function createWheel() {
            const wheelRadius = simParams.effectiveWheelRadius;
            const wheelThickness = simParams.effectiveWheelThickness;
            
            // Create a group to hold all wheel components
            const wheelGroup = new THREE.Group();
            // No rotation here - we'll rotate when positioning the wheel on the train
            
            // We're completely removing the red center now - not creating it at all
            // This avoids Z-fighting and other rendering issues
            
            // Add a high-contrast backing that's visible in all lighting conditions
            // Shrink the red disc to a tiny accent near the hub
            const backingRingGeometry = new THREE.RingGeometry(
                wheelRadius * 0.31, // Inner radius - moved closer to hub
                wheelRadius * 0.315, // Outer radius - just 0.5% difference for a barely visible accent
                32, // Segments
                1  // Rings
            );
            
            // Use MeshStandardMaterial with emissive properties for visibility in shadows
            const backingMaterial = new THREE.MeshStandardMaterial({
                color: 0x880000, // Deep red with good contrast against environment
                metalness: 0.2,
                roughness: 0.7,
                side: THREE.DoubleSide,
                emissive: 0x330000, // Subtle red glow
                emissiveIntensity: 0.4, // Visible in darkness
                transparent: false // Solid for better visibility
            });
            
            const backing = new THREE.Mesh(backingRingGeometry, backingMaterial);
            // Fix orientation issues by using proper rotation values
            backing.rotation.y = Math.PI / 2; // Rotate to align with wheel plane
            wheelGroup.add(backing);
            
            // Add an inner highlight ring for better definition
            const highlightRingGeometry = new THREE.RingGeometry(
                wheelRadius * 0.32, // Just outside hub
                wheelRadius * 0.33,
                32, 1
            );
            
            const highlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xDDDDDD, // Light color for contrast
                emissive: 0x999999,
                emissiveIntensity: 0.7,
                metalness: 0.1,
                roughness: 0.3
            });
            
            const highlightRing = new THREE.Mesh(highlightRingGeometry, highlightMaterial);
            highlightRing.rotation.x = Math.PI / 2;
            wheelGroup.add(highlightRing);
            
            // Add cream-colored middle ring (less bright than pure white)
            const middleRingGeometry = new THREE.TorusGeometry(
                wheelRadius * 0.85,  // Positioned between center and outer edge
                wheelThickness * 0.12,
                32, 8, Math.PI * 2
            );
            // Use MeshStandardMaterial for more realistic lighting
            const middleRingMaterial = new THREE.MeshStandardMaterial({
                color: 0xEAE0C8, // Soft cream color instead of bright white
                metalness: 0.1,    // Less metallic
                roughness: 0.7,    // More roughness to diffuse light
                emissive: 0x111111, // Slight emissive to maintain visibility
                emissiveIntensity: 0.05
            });
            const middleRing = new THREE.Mesh(middleRingGeometry, middleRingMaterial);
            // No rotation needed here anymore, will be rotated with the wheel
            wheelGroup.add(middleRing);
            
            // Add black outer ring (tire) with high-contrast edge for visibility
            const tireGeometry = new THREE.TorusGeometry(
                wheelRadius - (wheelThickness * 0.05),  // Outer edge
                wheelThickness * 0.1,
                32, 8, Math.PI * 2
            );
            // Use darker material with better edge definition
            const tireMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,        // Very dark gray rather than pure black
                metalness: 0.1,         // Rubber-like, not metallic
                roughness: 0.9,         // Very rough surface
                envMapIntensity: 0.5    // Less reflective
            });
            const tire = new THREE.Mesh(tireGeometry, tireMaterial);
            // No rotation here - will be rotated with the wheel
            wheelGroup.add(tire);
            
            // Add a highly visible outer ring highlight
            const tireHighlightGeometry = new THREE.TorusGeometry(
                wheelRadius - (wheelThickness * 0.05),  // Same as tire
                wheelThickness * 0.03,  // Thinner than the tire
                32, 8, Math.PI * 2
            );
            const tireHighlightMaterial = new THREE.MeshStandardMaterial({
                color: 0xCCCCCC,        // Light gray for contrast
                metalness: 0.2,
                roughness: 0.4,
                emissive: 0x555555,     // Subtle glow in darkness
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.7            // Semi-transparent for subtle effect
            });
            // Offset the highlight slightly to one side for better visibility
            const tireHighlight = new THREE.Mesh(tireHighlightGeometry, tireHighlightMaterial);
            tireHighlight.position.z = wheelThickness * 0.05; // Offset to edge
            wheelGroup.add(tireHighlight);
            
            // Add spokes with improved materials
            const spokeCount = 12; // Number of spokes
            // Use MeshStandardMaterial for more consistent lighting
            const spokeMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888, // Darker, aged metal color
                metalness: 0.6,   // Moderately metallic
                roughness: 0.5,   // Medium roughness for diffused reflections
                envMapIntensity: 0.3 // Reduce environment reflections
            });
            
            // Inner hub connection ring
            const innerRingGeometry = new THREE.TorusGeometry(
                wheelRadius * 0.4,
                wheelThickness * 0.05,
                16, 8, Math.PI * 2
            );
            const innerRing = new THREE.Mesh(innerRingGeometry, spokeMaterial);
            // No individual rotation
            wheelGroup.add(innerRing);
            
            // Outer spokes connection ring
            const outerRingGeometry = new THREE.TorusGeometry(
                wheelRadius * 0.75,
                wheelThickness * 0.05,
                16, 8, Math.PI * 2
            );
            const outerRing = new THREE.Mesh(outerRingGeometry, spokeMaterial);
            // No individual rotation
            wheelGroup.add(outerRing);
            
            // Create spokes
            for (let i = 0; i < spokeCount; i++) {
                const angle = (i / spokeCount) * Math.PI * 2;
                
                // Create spoke geometry (thin box)
                const spokeGeometry = new THREE.BoxGeometry(
                    wheelRadius * 0.35, // Length from hub to rim
                    wheelThickness * 0.08, // Width of spoke
                    wheelThickness * 0.08  // Height/thickness of spoke
                );
                
                const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
                
                // Position at middle distance between hub and rim
                spoke.position.set(
                    Math.cos(angle) * (wheelRadius * 0.575), // Position halfway between hub and rim
                    Math.sin(angle) * (wheelRadius * 0.575),
                    0
                );
                
                // Rotate to point from center to rim
                spoke.rotation.z = angle;
                
                wheelGroup.add(spoke);
                
                // Add a cross-spoke for more detail (offset by half the angle spacing)
                if (i % 2 === 0) { // Add cross spokes to every other main spoke
                    const crossSpokeGeometry = new THREE.BoxGeometry(
                        wheelRadius * 0.25, // Shorter than main spokes
                        wheelThickness * 0.06, // Slightly thinner
                        wheelThickness * 0.06
                    );
                    
                    const crossSpoke = new THREE.Mesh(crossSpokeGeometry, spokeMaterial);
                    
                    // Position offset from the main spoke
                    const crossAngle = angle + (Math.PI / spokeCount);
                    crossSpoke.position.set(
                        Math.cos(crossAngle) * (wheelRadius * 0.6),
                        Math.sin(crossAngle) * (wheelRadius * 0.6),
                        0
                    );
                    
                    // Rotate to create X pattern with main spoke
                    crossSpoke.rotation.z = crossAngle + (Math.PI / 4); // 45-degree angle
                    
                    wheelGroup.add(crossSpoke);
                }
            }
            
            // Add hub with more detail and improved materials
            const hubRadius = wheelRadius * 0.3;
            const hubThickness = wheelThickness * 1.2;
            const hubGeometry = new THREE.CylinderGeometry(
                hubRadius * 0.9,
                hubRadius * 0.9,
                hubThickness,
                16
            );
            
            // Use MeshStandardMaterial for consistent PBR rendering
            const hubMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,     // Dark metal gray
                metalness: 0.75,      // High metallic property
                roughness: 0.6,       // Medium roughness for realistic metal
                envMapIntensity: 0.4  // Moderate environment reflections
            });
            
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            // No individual rotation - will be rotated with the wheel
            wheelGroup.add(hub);
            
            // Add central axle hole with improved material
            const axleHoleGeometry = new THREE.CylinderGeometry(
                hubRadius * 0.4,
                hubRadius * 0.4,
                hubThickness * 1.1,
                12
            );
            const axleHoleMaterial = new THREE.MeshStandardMaterial({
                color: 0x0A0A0A,     // Nearly black but not pure black
                metalness: 0.3,        // Slightly metallic
                roughness: 0.9,        // Very rough for shadow depth
                side: THREE.DoubleSide // Render both sides
            });
            const axleHole = new THREE.Mesh(axleHoleGeometry, axleHoleMaterial);
            // No individual rotation - will be rotated with the wheel
            wheelGroup.add(axleHole);
            
            // Add bolts around the hub with washers - improved materials
            const boltCount = 8;
            const boltGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.2, 6);
            // Use MeshStandardMaterial for consistent rendering with other parts
            const boltMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,      // Darker steel color
                metalness: 0.8,        // High metalness for bolt
                roughness: 0.4,        // Medium-low roughness for machined surface
                envMapIntensity: 0.3   // Controlled reflectivity
            });
            
            const washerGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8);
            const washerMaterial = new THREE.MeshStandardMaterial({
                color: 0x777777,      // Slightly lighter than bolts
                metalness: 0.7,        // Slightly less metallic than bolts
                roughness: 0.5,        // More roughness than bolts
                envMapIntensity: 0.25  // Less reflective than bolts
            });
            
            for (let i = 0; i < boltCount; i++) {
                const angle = (i / boltCount) * Math.PI * 2;
                const radius = hubRadius * 1.3;
                
                // Add bolt
                const bolt = new THREE.Mesh(boltGeometry, boltMaterial);
                // No individual rotation
                bolt.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
                wheelGroup.add(bolt);
                
                // Add washer
                const washer = new THREE.Mesh(washerGeometry, washerMaterial);
                // No individual rotation
                washer.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
                wheelGroup.add(washer);
                
                // Add nut on the other side
                const nut = new THREE.Mesh(boltGeometry, boltMaterial);
                // No individual rotation
                nut.position.set(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                );
                nut.scale.set(0.8, 1, 0.8);
                wheelGroup.add(nut);
            }
            
            // Enable shadows for all components
            wheelGroup.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            return wheelGroup;
        }

        function createTrainBodyMesh(isLocomotive, eraType) {
            const bodyLength = isLocomotive ? simParams.locomotiveLength : simParams.carLength;
            const bodyHeight = isLocomotive ? 3 : 2.5; 
            const bodyWidth = 3;

            const bodyGeometry = new THREE.BoxGeometry(bodyLength, bodyHeight, bodyWidth);
            const bodyMaterial = new THREE.MeshLambertMaterial({
                color: isLocomotive ? darkOfficeGrey : getThemedEraColor(mediaEras[eraType].color),
                map: paperSpeckleTexture,
                transparent: true,
                opacity: 0.9
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.castShadow = true;
            bodyMesh.receiveShadow = true;

            const bodyEdges = new THREE.EdgesGeometry(bodyGeometry);
            const bodyOutline = new THREE.LineSegments(bodyEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
            bodyMesh.add(bodyOutline);

            // Add locomotive specific parts
            if (isLocomotive) {
                const smokestackGeometry = new THREE.CylinderGeometry(0.8, 1, 4, 16); 
                const smokestackMaterial = new THREE.MeshLambertMaterial({
                    color: mediumOfficeGrey, transparent: true, opacity: 0.9
                });
                const smokestack = new THREE.Mesh(smokestackGeometry, smokestackMaterial);
                smokestack.position.set(bodyLength / 2 - 1.5, bodyHeight / 2 + 1.5, 0); 
                smokestack.castShadow = true;
                const smokestackEdges = new THREE.EdgesGeometry(smokestackGeometry);
                const smokestackOutline = new THREE.LineSegments(smokestackEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
                smokestack.add(smokestackOutline);
                bodyMesh.add(smokestack);
            } else { // Add car specific symbols
                const symbols = createSymbolicContent(eraType, bodyHeight / 2); 
                bodyMesh.add(symbols);
            }
            return bodyMesh;
        }

        function createSymbolicContent(eraType, parentBodyHalfHeight) {
            const symbolGroup = new THREE.Group();
            const eraData = mediaEras[eraType];
            const color = getThemedEraColor(eraData.color);

            const symbolBaseRelativeY = parentBodyHalfHeight + 0.1; 

            switch (eraData.symbols) {
                case 'books':
                    for (let i = 0; i < 3; i++) {
                        const bookGeometry = new THREE.BoxGeometry(1.5, 0.3, 2);
                        const bookMaterial = new THREE.MeshLambertMaterial({
                            color: color.clone().offsetHSL(i * 0.05, 0, 0), transparent: true, opacity: 0.8
                        });
                        const book = new THREE.Mesh(bookGeometry, bookMaterial);
                        book.position.set(0, symbolBaseRelativeY + i * 0.4, 0); 
                        book.rotation.y = i * 0.2;
                        symbolGroup.add(book);
                        const bookEdges = new THREE.EdgesGeometry(bookGeometry);
                        const bookOutline = new THREE.LineSegments(bookEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
                        book.add(bookOutline);
                    }
                    break;
                case 'waves':
                    for (let i = 0; i < 3; i++) {
                        const ringGeometry = new THREE.TorusGeometry(1 + i * 0.5, 0.1, 8, 32);
                        const ringMaterial = new THREE.MeshLambertMaterial({
                            color: color, transparent: true, opacity: 0.4 - i * 0.1
                        });
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.position.y = symbolBaseRelativeY + 1.5;
                        ring.rotation.x = Math.PI / 2;
                        symbolGroup.add(ring);
                        ring.userData = { originalScale: 1 + i * 0.5, animationOffset: i * Math.PI / 3 };
                    }
                    break;
                case 'screen':
                    const screenGeometry = new THREE.BoxGeometry(2, 1.5, 0.2);
                    const screenMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(darkOfficeGrey_hex).offsetHSL(0,0,-0.1), transparent: true, opacity: 0.8
                    });
                    const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                    screen.position.y = symbolBaseRelativeY + 0.5;
                    symbolGroup.add(screen);
                    const screenEdges = new THREE.EdgesGeometry(screenGeometry);
                    const screenOutline = new THREE.LineSegments(screenEdges, new THREE.LineBasicMaterial({ color: edgeColor }));
                    screen.add(screenOutline);
                    const glowMaterial = new THREE.MeshLambertMaterial({
                        color: new THREE.Color(color).offsetHSL(0, 0.2, 0.1), transparent: true, opacity: 0.3,
                        emissive: new THREE.Color(color).offsetHSL(0, 0.1, 0.05), emissiveIntensity: 0.5
                    });
                    const glow = new THREE.Mesh(screenGeometry, glowMaterial);
                    glow.position.y = symbolBaseRelativeY + 0.5;
                    glow.position.z = 0.1;
                    glow.scale.set(1.1, 1.1, 1.1);
                    symbolGroup.add(glow);
                    glow.userData.animType = 'flicker';
                    break;
                case 'network':
                    const nodePositions = [
                        { x: 0, y: 0, z: 0 }, { x: 0.8, y: 0.4, z: 0.4 },
                        { x: -0.8, y: -0.4, z: 0.4 }, { x: 0.4, y: 0.8, z: -0.4 },
                        { x: -0.4, y: -0.8, z: -0.4 }
                    ];
                    nodePositions.forEach((pos, i) => {
                        const nodeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                        const nodeMaterial = new THREE.MeshLambertMaterial({
                            color: color, emissive: color.clone().multiplyScalar(0.3), transparent: true, opacity: 0.9
                        });
                        const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                        node.position.set(pos.x, pos.y + symbolBaseRelativeY + 0.5, pos.z);
                        node.castShadow = true;
                        symbolGroup.add(node);
                        if (i > 0) {
                            const points = [new THREE.Vector3(0, symbolBaseRelativeY + 0.5, 0), new THREE.Vector3(pos.x, pos.y + symbolBaseRelativeY + 0.5, pos.z)];
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            symbolGroup.add(line);
                        }
                    });
                    break;
            }
            return symbolGroup;
        }

        // Add a single train car (either locomotive or standard car)
        function addTrainCar(isLocomotive, eraType = null) {
            const carData = {
                group: new THREE.Group(), 
                wheels: [], 
                bodyMesh: null, 
                type: isLocomotive ? 'Locomotive' : 'Car',
                era: eraType, 
                u: 0, // Arc length position on the path (0-1)
            };

            const bodyLength = isLocomotive ? simParams.locomotiveLength : simParams.carLength;
            const bodyHeight = isLocomotive ? 3 : 2.5; 
            const bogieHeight = 0.5; // Fixed height for bogie geometry

            // Crucial: The car group's local Y=0 is set to align with the railVerticalOffset.
            // All children will be positioned relative to this 'track surface' Y=0.
            carData.group.position.y = simParams.railVerticalOffset; 

            const carBodyMesh = createTrainBodyMesh(isLocomotive, eraType);
            // Body's bottom is at Y=0 (track surface), so its center is half its height up
            carBodyMesh.position.y = bodyHeight / 2; 
            carData.group.add(carBodyMesh); 
            carData.bodyMesh = carBodyMesh; 

            // Wheels - Positioned so their center is at effectiveWheelRadius from the track surface
            const wheelZOffset = (simParams.trackGauge / 2) * 1.1; // Slightly reduced spacing between wheels
            const wheelAxleOffset = bodyLength / 2 - 2.0; // Distance from car ends
            const wheelYOffset = simParams.effectiveWheelRadius; // Height from track surface

            // Front Left Wheel
            const frontLeftWheel = createWheel();
            frontLeftWheel.rotation.z = Math.PI / 2; // Rotate to correct orientation
            frontLeftWheel.position.set(wheelAxleOffset, wheelYOffset, -wheelZOffset);
            carData.group.add(frontLeftWheel);
            carData.wheels.push(frontLeftWheel);
            
            // Front Right Wheel
            const frontRightWheel = createWheel();
            frontRightWheel.rotation.z = Math.PI / 2; // Rotate to correct orientation
            frontRightWheel.position.set(wheelAxleOffset, wheelYOffset, wheelZOffset);
            carData.group.add(frontRightWheel);
            carData.wheels.push(frontRightWheel);
            
            // Rear Left Wheel
            const rearLeftWheel = createWheel();
            rearLeftWheel.rotation.z = Math.PI / 2; // Rotate to correct orientation
            rearLeftWheel.position.set(-wheelAxleOffset, wheelYOffset, -wheelZOffset);
            carData.group.add(rearLeftWheel);
            carData.wheels.push(rearLeftWheel);
            
            // Rear Right Wheel
            const rearRightWheel = createWheel();
            rearRightWheel.rotation.z = Math.PI / 2; // Rotate to correct orientation
            rearRightWheel.position.set(-wheelAxleOffset, wheelYOffset, wheelZOffset);
            carData.group.add(rearRightWheel);
            carData.wheels.push(rearRightWheel);
            
            // Add bogies (the frames that hold the wheels)
            const bogieLength = 3.5; // Slightly longer bogie
            const bogieGeometry = new THREE.BoxGeometry(bogieLength, 0.3, wheelZOffset * 2 * 0.9); 
            const bogieMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            // Position bogies just above the wheel axles
            const bogieYPosition = wheelYOffset + 0.1; 

            // Front bogie
            const frontBogie = new THREE.Mesh(bogieGeometry, bogieMaterial);
            frontBogie.position.set(wheelAxleOffset, bogieYPosition, 0);
            frontBogie.castShadow = true;
            carData.group.add(frontBogie);
            
            // Rear bogie
            const rearBogie = new THREE.Mesh(bogieGeometry, bogieMaterial);
            rearBogie.position.set(-wheelAxleOffset, bogieYPosition, 0);
            rearBogie.castShadow = true;
            carData.group.add(rearBogie);

            // Coupling mechanism (visual only, for cars)
            if (!isLocomotive) {
                const couplingGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 16);
                const couplingMaterial = new THREE.MeshLambertMaterial({ color: couplingColor });
                // Position coupling mid-height of the body
                const couplingYPosition = (bodyHeight / 2) - 0.5; 
                const coupling = new THREE.Mesh(couplingGeometry, couplingMaterial);
                coupling.rotation.x = Math.PI / 2; 
                coupling.position.set(-bodyLength / 2 - simParams.couplingOffset, couplingYPosition, 0); 
                carData.group.add(coupling);
                
                const rearCoupling = coupling.clone();
                rearCoupling.position.set(bodyLength / 2 + simParams.couplingOffset, couplingYPosition, 0); 
                carData.group.add(rearCoupling);
            }
            
            // Set userData for click interaction
            carData.group.userData = {
                isLocomotive: isLocomotive,
                era: eraType,
                clickable: true,
                carData: carData 
            };
            
            scene.add(carData.group);
            
            if (isLocomotive) {
                trainCars.unshift(carData); 
            } else {
                trainCars.push(carData);
            }
        }

        // Resets and recreates all train cars
        function resetTrain() {
            trainCars.forEach(carData => scene.remove(carData.group));
            trainCars = [];
            trainCurrentU = 0; // Reset locomotive position on path
            focusedCarIndex = 0;
            currentEraDialogue = 'Print';

            // Add default cars
            addTrainCar(true); // Locomotive
            addTrainCar(false, 'Print');
            addTrainCar(false, 'Radio');
            addTrainCar(false, 'Television');
            addTrainCar(false, 'Internet');

            // Apply debug wheel rotations to the newly created cars
            applyDebugWheelStaticRotations();

            updateTrainInfoDisplay();
        }

        // --- UI & Event Handlers ---

        function setupUIControls() {
            // Speed control
            const speedInput = document.getElementById('speed');
            const speedValueDisplay = document.getElementById('speedValue');
            speedInput.addEventListener('input', (e) => {
                simParams.currentSpeed = parseFloat(e.target.value);
                speedValueDisplay.textContent = simParams.currentSpeed.toFixed(1);
                updateTrainInfoDisplay();
            });
            speedInput.value = simParams.currentSpeed; 
            speedValueDisplay.textContent = simParams.currentSpeed.toFixed(1);

            // Add Car button
            document.getElementById('addCarBtn').addEventListener('click', () => {
                const newEraIndex = trainCars.length - 1; 
                const eraKeys = Object.keys(mediaEras);
                const eraType = eraKeys[newEraIndex % eraKeys.length]; 
                addTrainCar(false, eraType);
                applyDebugWheelStaticRotations(); // Apply current debug rotations to new car
                updateTrainInfoDisplay();
            });

            // Reset Simulation button
            document.getElementById('resetSim').addEventListener('click', () => {
                resetTrain();
                // Reset camera to overview
                currentView = 0; 
                camera.position.set(simParams.trackRadius * 1.5, simParams.trackRadius * 0.8, simParams.trackRadius * 1.5);
                controls.target.set(0,0,0);
                controls.enabled = true;
            });
            
            // Toggle View button
            document.getElementById('toggleView').addEventListener('click', () => {
                toggleView(); 
            });

            // Focus Car button
            document.getElementById('focusCar').addEventListener('click', focusCar);

            // Talk to Era button
            document.getElementById('talkToEra').addEventListener('click', openDialogue);

            // Dialogue box buttons
            document.getElementById('closeDialogue').addEventListener('click', closeDialogue);
            document.getElementById('sendMessage').addEventListener('click', sendMessage);
            document.getElementById('userInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') sendMessage();
            });

            // --- Track & Train General Settings ---
            const trackRadiusSlider = document.getElementById('trackRadius');
            const trackRadiusValSpan = document.getElementById('trackRadiusVal');
            trackRadiusSlider.addEventListener('input', (e) => {
                simParams.trackRadius = parseFloat(e.target.value);
                trackRadiusValSpan.textContent = simParams.trackRadius.toFixed(0) + 'm';
                updateTrackGeometry();
                resetTrain(); // Reset train position when track changes
                updateTrainInfoDisplay();
            });
            trackRadiusSlider.value = simParams.trackRadius;
            trackRadiusValSpan.textContent = simParams.trackRadius.toFixed(0) + 'm';

            const trackGaugeSlider = document.getElementById('trackGauge');
            const trackGaugeValSpan = document.getElementById('trackGaugeVal');
            trackGaugeSlider.addEventListener('input', (e) => {
                simParams.trackGauge = parseFloat(e.target.value);
                trackGaugeValSpan.textContent = simParams.trackGauge.toFixed(1) + 'm';
                updateTrackGeometry();
                resetTrain(); // Reset train position when track changes
                updateTrainInfoDisplay();
            });
            trackGaugeSlider.value = simParams.trackGauge;
            trackGaugeValSpan.textContent = simParams.trackGauge.toFixed(1) + 'm';

            const railVerticalOffsetSlider = document.getElementById('railVerticalOffset');
            const railVerticalOffsetValSpan = document.getElementById('railVerticalOffsetVal');
            railVerticalOffsetSlider.addEventListener('input', (e) => {
                simParams.railVerticalOffset = parseFloat(e.target.value);
                railVerticalOffsetValSpan.textContent = simParams.railVerticalOffset.toFixed(2) + 'm';
                updateTrackGeometry(); // Update track position
                trainCars.forEach(car => car.group.position.y = simParams.railVerticalOffset); // Update train position without full reset
            });
            railVerticalOffsetSlider.value = simParams.railVerticalOffset;
            railVerticalOffsetValSpan.textContent = simParams.railVerticalOffset.toFixed(2) + 'm';

            const bankingMultiplierSlider = document.getElementById('bankingMultiplier');
            const bankingMultiplierValSpan = document.getElementById('bankingMultiplierVal');
            bankingMultiplierSlider.addEventListener('input', (e) => {
                simParams.bankingMultiplier = parseFloat(e.target.value);
                bankingMultiplierValSpan.textContent = simParams.bankingMultiplier.toFixed(2) + 'x';
            });
            bankingMultiplierSlider.value = simParams.bankingMultiplier;
            bankingMultiplierValSpan.textContent = simParams.bankingMultiplier.toFixed(2) + 'x';

            // --- Wheel Local Orientation Debuggers ---
            const locoYOffsetSlider = document.getElementById('locoYOffset');
            const locoYOffsetValSpan = document.getElementById('locoYOffsetVal');
            locoYOffsetSlider.addEventListener('input', (e) => {
                simParams.debugLocoYOffset = parseFloat(e.target.value);
                locoYOffsetValSpan.textContent = simParams.debugLocoYOffset.toFixed(2);
            });
            locoYOffsetSlider.value = simParams.debugLocoYOffset;
            locoYOffsetValSpan.textContent = simParams.debugLocoYOffset.toFixed(2);

            const wheelStaticRotXSlider = document.getElementById('wheelStaticRotX');
            const wheelStaticRotXValSpan = document.getElementById('wheelStaticRotXVal');
            wheelStaticRotXSlider.addEventListener('input', (e) => {
                simParams.debugWheelRotX = parseFloat(e.target.value) * (Math.PI / 180);
                wheelStaticRotXValSpan.textContent = e.target.value + '°';
                applyDebugWheelStaticRotations();
            });
            wheelStaticRotXSlider.value = simParams.debugWheelRotX * (180 / Math.PI);
            wheelStaticRotXValSpan.textContent = (simParams.debugWheelRotX * (180 / Math.PI)).toFixed(0) + '°';

            const wheelStaticRotYSlider = document.getElementById('wheelStaticRotY');
            const wheelStaticRotYValSpan = document.getElementById('wheelStaticRotYVal');
            wheelStaticRotYSlider.addEventListener('input', (e) => {
                simParams.debugWheelRotY = parseFloat(e.target.value) * (Math.PI / 180);
                wheelStaticRotYValSpan.textContent = e.target.value + '°';
                applyDebugWheelStaticRotations();
            });
            wheelStaticRotYSlider.value = simParams.debugWheelRotY * (180 / Math.PI);
            wheelStaticRotYValSpan.textContent = (simParams.debugWheelRotY * (180 / Math.PI)).toFixed(0) + '°';

            const wheelStaticRotZSlider = document.getElementById('wheelStaticRotZ');
            const wheelStaticRotZValSpan = document.getElementById('wheelStaticRotZVal');
            wheelStaticRotZSlider.addEventListener('input', (e) => {
                simParams.debugWheelRotZ = parseFloat(e.target.value) * (Math.PI / 180);
                wheelStaticRotZValSpan.textContent = e.target.value + '°';
                applyDebugWheelStaticRotations();
            });
            wheelStaticRotZSlider.value = simParams.debugWheelRotZ * (180 / Math.PI);
            wheelStaticRotZValSpan.textContent = (simParams.debugWheelRotZ * (180 / Math.PI)).toFixed(0) + '°';

            const wheelRollingAxisSelect = document.getElementById('wheelRollingAxis');
            wheelRollingAxisSelect.addEventListener('change', (e) => {
                simParams.debugWheelRollingAxis = e.target.value;
            });
            wheelRollingAxisSelect.value = simParams.debugWheelRollingAxis;

            // Mouse clicks for car interaction (raycaster)
            renderer.domElement.addEventListener('click', onMouseClick);
        }

        function updateTrainInfoDisplay() {
            document.getElementById('trainInfoDisplay').textContent = `Cars: ${trainCars.length} | Speed: ${simParams.currentSpeed.toFixed(1)}x`;
            document.getElementById('currentEra').textContent = `Era: ${currentEraDialogue} Era`;
        }

        // Helper function to apply debug static rotations to all wheels live
        function applyDebugWheelStaticRotations() {
            trainCars.forEach(carData => {
                carData.wheels.forEach(wheel => {
                    // First, apply the standard "wheel" orientation to the cylinder (height along X-axis for a Z-forward train)
                    // This sets the base rotation to make a cylinder look like a train wheel on a track.
                    wheel.rotation.set(0, 0, Math.PI / 2); 
                    // Then, apply debug rotations on top of that.
                    // These are local rotations *relative to the wheel's current orientation*.
                    wheel.rotateX(simParams.debugWheelRotX);
                    wheel.rotateY(simParams.debugWheelRotY);
                    wheel.rotateZ(simParams.debugWheelRotZ);
                });
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            if (document.getElementById('dialogue').classList.contains('active')) return; 

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            let clickedCarData = null;
            for (const carData of trainCars) {
                if (carData.group.userData.clickable) { 
                    const intersects = raycaster.intersectObjects(carData.group.children, true);
                    if (intersects.length > 0) {
                        let targetGroup = intersects[0].object;
                        while (targetGroup && targetGroup.parent && !targetGroup.userData.carData) {
                            targetGroup = targetGroup.parent;
                        }
                        if (targetGroup && targetGroup.userData.carData) {
                             clickedCarData = targetGroup.userData.carData;
                             break;
                        }
                    }
                }
            }
            
            if (clickedCarData && !clickedCarData.isLocomotive) { 
                currentEraDialogue = clickedCarData.era;
                openDialogue();
            }
        }

        function toggleView() {
            // Reset any dynamic view flags
            camera.userData.isDynamicView = false;
            camera.userData.isAudienceReaction = false;
            camera.userData.isTrainRush = false;
            
            currentView = (currentView + 1) % 21; // Now cycles through 21 views (added avant-garde views)
            
            if (currentView === 0) { // Overview
                camera.position.set(simParams.trackRadius * 1.5, simParams.trackRadius * 0.8, simParams.trackRadius * 1.5);
                controls.target.set(0,0,0);
                controls.enabled = true; // Enable orbit controls
                document.getElementById('info').textContent = 'Overview Camera - Click to change view';
            } else if (currentView === 1) { // Side view
                camera.position.set(0, simParams.trackRadius * 0.5, simParams.trackRadius * 2);
                controls.target.set(0,0,0);
                controls.enabled = true; // Enable orbit controls
                document.getElementById('info').textContent = 'Side View Camera - Click to change view';
            } else if (currentView === 2) { // Following view
                controls.enabled = false; // Disable orbit controls for automatic following
                document.getElementById('info').textContent = 'Following Camera - Click to change view';
            } else if (currentView === 3) { // Dynamic cinematic front engine view
                controls.enabled = false; // Disable orbit controls
                if (trainCars.length > 0) {
                    const locomotive = trainCars[0]; // First car is the locomotive
                    // Position camera in front of the locomotive, looking back at it with a dramatic low angle
                    const engineOffset = new THREE.Vector3(locomotive.bodyMesh.position.x + 4, 0.5, 0); // Lower position
                    camera.position.copy(locomotive.group.position).add(engineOffset);
                    // Look up at the locomotive for dramatic effect
                    camera.lookAt(new THREE.Vector3(
                        locomotive.group.position.x,
                        locomotive.group.position.y + 3, // Look up at the train
                        locomotive.group.position.z
                    ));
                    document.getElementById('info').textContent = 'Dramatic Engine View - Click to change view';
                }
            } else if (currentView === 4) { // La Ciotat Station arrival view
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    // Position camera on the station platform looking at the track
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Platform-level view looking at the tracks
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 5, // On the platform
                        1.0,                                   // Eye level on platform
                        stationPos.z + towardTrackVector.z * 5 // On the platform
                    );
                    
                    // Look toward the track where train will arrive
                    const lookTarget = new THREE.Vector3(
                        Math.cos(stationAngle) * simParams.trackRadius,
                        1.0, // Same height
                        Math.sin(stationAngle) * simParams.trackRadius
                    );
                    camera.lookAt(lookTarget);
                    document.getElementById('info').textContent = 'La Ciotat Station Arrival View - Click to change view';
                }
            } else if (currentView === 5) { // Dynamic sweeping track view
                controls.enabled = false; // Disable orbit controls
                
                // Set the flag to indicate this is a dynamic view that should be updated in the animation loop
                camera.userData.isDynamicView = true;
                
                // Initial position - will be continuously updated in the animation loop
                const trackAngle = (Date.now() * 0.0005) % (Math.PI * 2); // Slowly moving angle
                const height = 3 + Math.sin(Date.now() * 0.001) * 2; // Gently undulating height
                
                // Position camera along the track but slightly elevated
                camera.position.set(
                    Math.cos(trackAngle) * simParams.trackRadius * 0.8,
                    height,
                    Math.sin(trackAngle) * simParams.trackRadius * 0.8
                );
                
                // Look ahead along the track
                const lookAheadAngle = trackAngle + Math.PI/8;
                camera.lookAt(
                    Math.cos(lookAheadAngle) * simParams.trackRadius * 0.8,
                    height,
                    Math.sin(lookAheadAngle) * simParams.trackRadius * 0.8
                );
                document.getElementById('info').textContent = 'Dynamic Track View - Click to change view';
                
                // For this view, we'll continuously update in the animation loop
                camera.userData.isDynamicView = true;
            } else if (currentView === 6) { // Station overhead view
                controls.enabled = false; // Disable orbit controls
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    
                    // Position camera above the station looking down
                    camera.position.set(
                        stationPos.x,
                        stationPos.y + 15, // High above station
                        stationPos.z
                    );
                    
                    // Look down at the station
                    camera.lookAt(stationPos);
                    document.getElementById('info').textContent = 'Station Overhead View - Click to change view';
                }
            } else if (currentView === 7) { // Passenger perspective on train
                controls.enabled = false; // Disable orbit controls
                if (trainCars.length > 1) { // At least one passenger car
                    const passengerCar = trainCars[1]; // First passenger car after locomotive
                    
                    // Position camera inside the passenger car
                    const passengerOffset = new THREE.Vector3(0, 2, 0); // Sitting position
                    camera.position.copy(passengerCar.group.position).add(passengerOffset);
                    
                    // Look out the window (side of the train)
                    const lookOffset = new THREE.Vector3(0, 1.8, 3); // Looking out window
                    camera.lookAt(passengerCar.group.position.clone().add(lookOffset));
                    document.getElementById('info').textContent = 'Passenger View - Click to change view';
                }
            } else if (currentView === 8) { // Track-level view
                controls.enabled = false; // Disable orbit controls
                // Position camera extremely low on the tracks, looking along them
                camera.position.set(simParams.trackRadius * 0.7, 0.2, 0); // Very low on tracks
                // Look toward the center/around the curve
                camera.lookAt(0, 0.2, 0);
                document.getElementById('info').textContent = 'Ant\'s View on Tracks - Click to change view';
            } else if (currentView === 9) { // Bird's eye view
                controls.enabled = false; // Disable orbit controls
                // Position camera very high above, looking down at an angle
                camera.position.set(
                    simParams.trackRadius * 0.5, 
                    simParams.trackRadius * 2.5, // Very high
                    simParams.trackRadius * 0.5
                );
                // Look down at the scene
                camera.lookAt(0, 0, 0);
                document.getElementById('info').textContent = 'Bird\'s Eye View - Click to change view';
            } else if (currentView === 10) { // Wheel close-up view
                controls.enabled = false; // Disable orbit controls for wheel view
                // Position camera close to the first wheel of the locomotive
                if (trainCars.length > 0) {
                    const wheelRadius = simParams.effectiveWheelRadius;
                    const wheel = trainCars[0].wheels[0]; // First wheel of the first car (locomotive)
                    
                    // Position camera to the side and slightly above the wheel
                    const offset = new THREE.Vector3(wheelRadius * 0.8, wheelRadius * 0.5, 0);
                    camera.position.copy(wheel.position).add(offset);
                    
                    // Look at the center of the wheel
                    camera.lookAt(wheel.position);
                    document.getElementById('info').textContent = 'Wheel Close-Up View - Click to change view';
                }
            } else if (currentView === 11) { // Station ticket window view
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Position camera inside the station at human height (1.65m)
                    // Move camera slightly behind the front wall as if looking through a ticket window
                    camera.position.set(
                        stationPos.x + Math.sin(stationAngle) * 3.5, // Inside the station
                        1.65, // Human eye level
                        stationPos.z - Math.cos(stationAngle) * 3.5  // Inside the station
                    );
                    
                    // Look toward the track through the ticket window
                    const lookTarget = new THREE.Vector3(
                        Math.cos(stationAngle) * simParams.trackRadius,
                        1.65, // Same height
                        Math.sin(stationAngle) * simParams.trackRadius
                    );
                    camera.lookAt(lookTarget);
                    document.getElementById('info').textContent = 'Station Ticket Window View - Click to change view';
                }
            } else if (currentView === 12) { // Platform waiting view
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Position camera at the end of the platform
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 5, // On the platform
                        1.65,                                  // Human eye level
                        stationPos.z + towardTrackVector.z * 9 // At the end of the platform
                    );
                    
                    // Look down the tracks
                    const lookAngle = stationAngle - Math.PI/4; // Look along the tracks
                    const lookTarget = new THREE.Vector3(
                        Math.cos(lookAngle) * simParams.trackRadius,
                        1.65, // Same height
                        Math.sin(lookAngle) * simParams.trackRadius
                    );
                    camera.lookAt(lookTarget);
                    document.getElementById('info').textContent = 'Platform Waiting View - Click to change view';
                }
            } else if (currentView === 13) { // Station entrance view
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Position camera outside the station entrance
                    const entranceOffset = new THREE.Vector3(
                        Math.sin(stationAngle + Math.PI) * 5, // Behind the station
                        0,
                        Math.cos(stationAngle + Math.PI) * 5  // Behind the station
                    );
                    
                    camera.position.set(
                        stationPos.x + entranceOffset.x, // Outside the entrance
                        1.65,                          // Human eye level
                        stationPos.z + entranceOffset.z  // Outside the entrance
                    );
                    
                    // Look toward the station and tracks beyond
                    camera.lookAt(stationPos);
                    document.getElementById('info').textContent = 'Station Entrance View - Click to change view';
                }
            } else if (currentView === 14) { // Platform Edge Left View
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Position camera at the left edge of the platform
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 1.8, // Right at platform edge
                        1.65,                                    // Human eye level
                        stationPos.z + towardTrackVector.z * 1.8 - 9 // Left side of platform
                    );
                    
                    // Look toward the approaching train
                    const lookAngle = stationAngle - Math.PI/6; // Look along the approaching train
                    const lookTarget = new THREE.Vector3(
                        Math.cos(lookAngle) * simParams.trackRadius,
                        1.65, // Same height
                        Math.sin(lookAngle) * simParams.trackRadius
                    );
                    camera.lookAt(lookTarget);
                    document.getElementById('info').textContent = 'Platform Edge Left View - Click to change view';
                }
            } else if (currentView === 15) { // Platform Edge Center View
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Position camera at the center edge of platform
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 1.8, // Right at platform edge
                        1.65,                                    // Human eye level
                        stationPos.z + towardTrackVector.z * 1.8  // Center of platform
                    );
                    
                    // Look directly at the track
                    camera.lookAt(new THREE.Vector3(
                        Math.cos(stationAngle) * simParams.trackRadius,
                        1.65, // Same height
                        Math.sin(stationAngle) * simParams.trackRadius
                    ));
                    document.getElementById('info').textContent = 'Platform Edge Center View - Click to change view';
                }
            } else if (currentView === 16) { // Platform Edge Right View
                controls.enabled = false; // Disable orbit controls
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Position camera at the right edge of platform
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 1.8, // Right at platform edge
                        1.65,                                    // Human eye level
                        stationPos.z + towardTrackVector.z * 1.8 + 9 // Right side of platform
                    );
                    
                    // Look toward the departing train
                    const lookAngle = stationAngle + Math.PI/6; // Look along the departing train
                    const lookTarget = new THREE.Vector3(
                        Math.cos(lookAngle) * simParams.trackRadius,
                        1.65, // Same height
                        Math.sin(lookAngle) * simParams.trackRadius
                    );
                    camera.lookAt(lookTarget);
                    document.getElementById('info').textContent = 'Platform Edge Right View - Click to change view';
                }
            } else if (currentView === 17) { // Audience Reaction View - historical homage
                controls.enabled = false; // Disable orbit controls
                // This view simulates the famous audience reaction to the original film
                // The camera will shake and back away as the train approaches
                
                // Set a flag that the animation loop will use
                camera.userData.isAudienceReaction = true;
                
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Position camera at the edge of the platform with slight offset
                    // Similar to the original film angle but with artistic license
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 2, // Right at platform edge
                        1.65,                                   // Human eye level
                        stationPos.z + towardTrackVector.z * 2  // Center of platform
                    );
                    
                    // Look directly at the track - classic 45-degree angle of original film
                    camera.lookAt(new THREE.Vector3(
                        Math.cos(stationAngle) * simParams.trackRadius * 0.9,
                        1.65, // Same height
                        Math.sin(stationAngle) * simParams.trackRadius * 0.9
                    ));
                    
                    document.getElementById('info').textContent = 'Audience Reaction View (1895) - Click to change view';
                }
            } else if (currentView === 18) { // Train Rush - Avant-Garde Homage
                controls.enabled = false; // Disable orbit controls
                // This view creates the dramatic perspective of the train coming directly at the viewer
                // Will be updated dynamically in the animation loop
                
                // Set a flag that the animation loop will use
                camera.userData.isTrainRush = true;
                
                // Position camera extremely low on the tracks, looking UP at approaching train
                // Get locomotive position
                if (trainCars.length > 0) {
                    const loco = trainCars[0];
                    const locoPath = trainPathCurve.getPoint(loco.u);
                    
                    // Position camera on track ahead of locomotive
                    const locoAngle = Math.atan2(locoPath.y, locoPath.x);
                    const lookAheadAngle = locoAngle - Math.PI/12; // Slightly ahead
                    
                    camera.position.set(
                        Math.cos(lookAheadAngle) * simParams.trackRadius,
                        0.3, // Very low on track
                        Math.sin(lookAheadAngle) * simParams.trackRadius
                    );
                    
                    // Look directly at the locomotive
                    camera.lookAt(new THREE.Vector3(
                        locoPath.x,
                        1.8, // Look up at the front of the locomotive
                        locoPath.y
                    ));
                    
                    document.getElementById('info').textContent = 'Train Rush View - Click to change view';
                }
            } else if (currentView === 19) { // Lumière POV - Historical Filmmaker
                controls.enabled = false; // Disable orbit controls
                // This view simulates the perspective of the Lumière Brothers filming
                // Position just beside the platform with vintage camera framing
                
                // Verify the station exists
                if (scene.stationGroup) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25; // Same angle used when creating the station
                    
                    // Get the direction vector from station to track
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Position camera as if it's a tripod-mounted camera beside the platform
                    // Slightly off to the side, as the Lumières would have positioned it
                    camera.position.set(
                        stationPos.x + towardTrackVector.x * 3 + Math.cos(stationAngle + Math.PI/2) * 2,
                        1.7, // Slightly higher - on a tripod
                        stationPos.z + towardTrackVector.z * 3 + Math.sin(stationAngle + Math.PI/2) * 2
                    );
                    
                    // Look at a diagonal angle toward the arriving train path
                    const lookAngle = stationAngle - Math.PI/12;
                    camera.lookAt(new THREE.Vector3(
                        Math.cos(lookAngle) * simParams.trackRadius * 0.9,
                        1.2, // Lower to get the full train
                        Math.sin(lookAngle) * simParams.trackRadius * 0.9
                    ));
                    
                    // Add a subtle Dutch angle to make it feel like vintage footage
                    camera.rotation.z = Math.PI * 0.01; // Slight tilt
                    
                    document.getElementById('info').textContent = 'Lumière Brothers POV (1895) - Click to change view';
                }
            } else if (currentView === 20) { // Memory Collapse - Abstract Avant-Garde
                controls.enabled = false; // Disable orbit controls
                // This is a highly artistic view that represents the collision of past and present
                // A kaleidoscopic view that collapses time and space
                
                // Get the position of the station and locomotive
                if (scene.stationGroup && trainCars.length > 0) {
                    const stationPos = scene.stationGroup.children[0].position.clone();
                    const stationAngle = Math.PI * 0.25;
                    
                    const loco = trainCars[0];
                    const locoPath = trainPathCurve.getPoint(loco.u);
                    
                    // Position camera in a kind of impossible space between station and track
                    // Neither fully at platform nor on train - an in-between space
                    
                    // Create a position halfway between station platform and locomotive
                    // But elevated at an impossible angle - like a dream perspective
                    const midpoint = new THREE.Vector3();
                    midpoint.x = (stationPos.x + locoPath.x) * 0.5;
                    midpoint.z = (stationPos.z + locoPath.y) * 0.5;
                    
                    camera.position.set(
                        midpoint.x,
                        5.5, // Elevated, dreamlike perspective
                        midpoint.z
                    );
                    
                    // Point toward the center but with dramatic tilt
                    camera.lookAt(0, -3, 0);
                    
                    // Add a extreme Dutch angle for surreal effect
                    camera.rotation.z = Math.sin(Date.now() * 0.001) * 0.2; // Subtle oscillation
                    
                    document.getElementById('info').textContent = 'Memory Collapse (Avant-Garde) - Click to change view';
                }
            }
            
            controls.update(); 
        }

        function focusCar() {
            focusedCarIndex = (focusedCarIndex + 1);
            if (focusedCarIndex >= trainCars.length) { 
                 focusedCarIndex = 0; // Cycle back to locomotive
            }
            
            const carData = trainCars[focusedCarIndex];
            currentEraDialogue = carData.era || "Locomotive"; 
            updateTrainInfoDisplay();
            
            const carGroup = carData.group;
            const carPosition = carGroup.position;
            const offsetVec = new THREE.Vector3();
            carGroup.getWorldDirection(offsetVec); 
            offsetVec.negate(); 
            offsetVec.multiplyScalar(20); 

            camera.position.copy(carPosition).add(offsetVec);
            camera.position.y = carPosition.y + 10; 
            controls.target.copy(carPosition); 
            controls.update();
        }

        function openDialogue() {
            document.getElementById('dialogue').classList.add('active'); 
            document.getElementById('dialogueTitle').textContent = `Conversation with ${currentEraDialogue} Era`;
            document.getElementById('userInput').focus();
            document.getElementById('messageHistory').innerHTML = `
                <div class="message era">
                    <strong>${currentEraDialogue} Era:</strong> ${mediaEras[currentEraDialogue].personality}
                </div>
            `;
            document.getElementById('messageHistory').scrollTop = document.getElementById('messageHistory').scrollHeight; 
        }

        function closeDialogue() {
            document.getElementById('dialogue').classList.remove('active');
        }

        function sendMessage() {
            const input = document.getElementById('userInput');
            const message = input.value.trim();
            if (!message) return;

            const history = document.getElementById('messageHistory');
            
            const userDiv = document.createElement('div');
            userDiv.className = 'message user';
            userDiv.textContent = `You: ${message}`;
            history.appendChild(userDiv);
            history.scrollTop = history.scrollHeight; 

            const eraResponse = getEraResponse(currentEraDialogue, message);
            const eraDiv = document.createElement('div');
            eraDiv.className = 'message era';
            eraDiv.innerHTML = `<strong>${currentEraDialogue} Era:</strong> ${eraResponse}`;
            
            setTimeout(() => {
                history.appendChild(eraDiv);
                history.scrollTop = history.scrollHeight; 
            }, 700); 

            input.value = ''; 
        }

        function getEraResponse(eraType, userMessage) {
            const eraData = mediaEras[eraType];
            const responses = eraData.responses;
            const lowerCaseMessage = userMessage.toLowerCase();
            
            if (lowerCaseMessage.includes('knowledge') || lowerCaseMessage.includes('information') || lowerCaseMessage.includes('learn')) {
                return responses.knowledge;
            } else if (lowerCaseMessage.includes('technology') || lowerCaseMessage.includes('technical') || lowerCaseMessage.includes('how')) {
                return responses.technology;
            } else if (lowerCaseMessage.includes('society') || lowerCaseMessage.includes('culture') || lowerCaseMessage.includes('people') || lowerCaseMessage.includes('social')) {
                return responses.society;
            } else if (lowerCaseMessage.includes('future') || lowerCaseMessage.includes('next') || lowerCaseMessage.includes('evolution') || lowerCaseMessage.includes('what comes')) {
                return responses.future;
            } else if (lowerCaseMessage.includes('change') || lowerCaseMessage.includes('transform') || lowerCaseMessage.includes('influence') || lowerCaseMessage.includes('impact')) {
                return responses.change;
            } else if (lowerCaseMessage.includes('hello') || lowerCaseMessage.includes('hi') || lowerCaseMessage.includes('greet')) {
                return eraData.personality; 
            } else {
                const generalResponses = [
                    "That's an interesting thought. In my era, we focused on...",
                    "Such inquiries remind me of the foundational principles of my time.",
                    "To truly understand, you must consider the unique perspective I offer."
                ];
                return generalResponses[Math.floor(Math.random() * generalResponses.length)];
            }
        }

        // --- Main Animation Loop (Path-Based Circular Following) ---
        const position2D = new THREE.Vector2();
        const lookAheadPoint = new THREE.Vector2(); 

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta(); 

            // Update leader's (locomotive's) position along the path
            const linearDistanceMoved = simParams.currentSpeed * deltaTime;
            const uMoved = linearDistanceMoved / trainPathTotalLength;
            trainCurrentU = (trainCurrentU + uMoved) % 1; 

            // Train following algorithm (Path-binding)
            for (let i = 0; i < trainCars.length; i++) {
                const carData = trainCars[i];
                const segmentGroup = carData.group;
                const segmentLength = (carData.type === 'Locomotive') ? simParams.locomotiveLength : simParams.carLength;

                let segmentU;
                if (i === 0) { // Locomotive (leader)
                    segmentU = trainCurrentU;
                } else { // Trailing Cars - calculate U based on arc length behind the previous car
                    const prevCarData = trainCars[i - 1];
                    const prevSegmentLength = (prevCarData.type === 'Locomotive') ? simParams.locomotiveLength : simParams.carLength;
                    
                    const arcLengthBetweenCenters = (prevSegmentLength / 2) + (segmentLength / 2) + simParams.couplingOffset;
                    const uOffset = arcLengthBetweenCenters / trainPathTotalLength;
                    
                    segmentU = (prevCarData.u - uOffset);
                    segmentU = (segmentU + 1) % 1; 
                }
                carData.u = segmentU; 

                // --- PATH FOLLOWING: Position ---
                trainPathCurve.getPoint(segmentU, position2D); 
                segmentGroup.position.x = position2D.x;
                segmentGroup.position.z = position2D.y;
                
                // --- PATH FOLLOWING: Rotation (Orientation) ---
                const lookAheadDistance = segmentLength * 0.1; 
                const lookAheadU = (segmentU + (lookAheadDistance / trainPathTotalLength)) % 1;
                trainPathCurve.getPoint(lookAheadU, lookAheadPoint);

                segmentGroup.lookAt(lookAheadPoint.x, segmentGroup.position.y, lookAheadPoint.y); 

                // IMPORTANT FIX: Hardcode 90-degree yaw because the model's length axis is X, but lookAt uses Z as forward
                segmentGroup.rotateY(Math.PI / 2);
                // Apply user's fine-tuning offset on top of the fixed rotation
                segmentGroup.rotateY(simParams.debugLocoYOffset); 

                // --- Banking on Curves (rotation.x) ---
                const gravity = 9.81; 
                const idealBankAngle = (simParams.currentSpeed * simParams.currentSpeed) / (simParams.trackRadius * gravity); 
                
                const maxAllowedBank = Math.PI / 6; 
                let finalBankAngle = THREE.MathUtils.clamp(idealBankAngle * simParams.bankingMultiplier, -maxAllowedBank, maxAllowedBank);
                
                segmentGroup.rotateX(-finalBankAngle); 

                // Update wheels for current segment with smoother rotation
                // Calculate rotation based on distance traveled, not just speed
                const distanceTraveled = simParams.currentSpeed * deltaTime;
                const wheelRotationAngle = distanceTraveled / simParams.effectiveWheelRadius;
                
                // Apply smooth rotation with frame-rate independent calculation
                carData.wheels.forEach(wheel => {
                    // Use continuous rotation to avoid visual strobing
                    wheel.rotation.z = (wheel.rotation.z + wheelRotationAngle) % (Math.PI * 2);
                });
            }

            // Animate symbolic elements (Radio waves, TV flicker)
            trainCars.forEach(carData => {
                const eraType = carData.era;
                if (!eraType) return; 
                const carBodyMesh = carData.bodyMesh; 
                const symbols = carBodyMesh.children.find(child => child.isGroup && child.children.length > 0); 

                if (symbols && eraType === 'Radio') {
                    symbols.children.forEach(child => {
                        if (child.geometry && child.geometry.type === 'TorusGeometry') { 
                            const animOffset = child.userData.animationOffset || 0;
                            const scaleFactor = 1 + Math.sin(clock.elapsedTime * 2 + animOffset) * 0.2;
                            child.scale.setScalar(scaleFactor);
                            child.material.opacity = 0.4 - (scaleFactor - 1) * 0.5;
                        }
                    });
                } else if (symbols && eraType === 'Television') {
                    symbols.children.forEach(child => {
                        if (child.userData.animType === 'flicker') { 
                            child.material.opacity = 0.3 + Math.sin(clock.elapsedTime * 20) * 0.1;
                            child.material.emissiveIntensity = 0.5 + Math.sin(clock.elapsedTime * 15) * 0.2;
                        }
                    });
                }
            });

            // Camera following for 'Following View'
            if (currentView === 2) {
                const targetLocoPos = trainCars[0].group.position;
                const forwardDir = new THREE.Vector3();
                trainCars[0].group.getWorldDirection(forwardDir); 
                forwardDir.negate(); 

                const cameraOffsetDistance = 20; 
                const cameraOffsetHeight = 10;  

                camera.position.copy(targetLocoPos).add(forwardDir.multiplyScalar(cameraOffsetDistance));
                camera.position.y = targetLocoPos.y + cameraOffsetHeight;
                controls.target.copy(targetLocoPos); 
            }
            
            // Handle dynamic camera view (View #5)
            if (camera.userData.isDynamicView) {
                // Create a dynamic sweeping camera that moves along the track
                const trackAngle = (Date.now() * 0.0005) % (Math.PI * 2); // Slowly moving angle
                const height = 3 + Math.sin(Date.now() * 0.001) * 2; // Gently undulating height
                
                // Position camera along the track but slightly elevated
                camera.position.set(
                    Math.cos(trackAngle) * simParams.trackRadius * 0.8,
                    height,
                    Math.sin(trackAngle) * simParams.trackRadius * 0.8
                );
                
                // Look ahead along the track
                const lookAheadAngle = trackAngle + Math.PI/8;
                camera.lookAt(
                    Math.cos(lookAheadAngle) * simParams.trackRadius * 0.8,
                    height,
                    Math.sin(lookAheadAngle) * simParams.trackRadius * 0.8
                );
            }
            
            // Handle Audience Reaction camera (View #17)
            if (camera.userData.isAudienceReaction && trainCars.length > 0) {
                // Get the locomotive position
                const loco = trainCars[0];
                const locoPos = new THREE.Vector3();
                
                // Get the current position and target
                const stationPos = scene.stationGroup.children[0].position.clone();
                const stationAngle = Math.PI * 0.25;
                const locoPath = trainPathCurve.getPoint(loco.u);
                locoPos.set(locoPath.x, 1.65, locoPath.y);
                
                // Calculate distance between locomotive and camera
                const distanceToTrain = camera.position.distanceTo(locoPos);
                
                // When train approaches within certain distance, add shake and pull back
                if (distanceToTrain < 25) {
                    // Scale factor - more intense as train gets closer
                    const intensityFactor = 1.0 - (distanceToTrain / 25);
                    
                    // Add camera shake
                    const shakeAmount = intensityFactor * 0.05;
                    camera.position.x += (Math.random() - 0.5) * shakeAmount;
                    camera.position.y += (Math.random() - 0.5) * shakeAmount;
                    camera.position.z += (Math.random() - 0.5) * shakeAmount;
                    
                    // Pull back camera slightly as train approaches (simulate audience backing away in fear)
                    const towardTrackVector = new THREE.Vector3(
                        -Math.cos(stationAngle),
                        0,
                        -Math.sin(stationAngle)
                    ).normalize();
                    
                    // Gradually move away from track
                    camera.position.x -= towardTrackVector.x * intensityFactor * 0.05;
                    camera.position.z -= towardTrackVector.z * intensityFactor * 0.05;
                    camera.position.y += intensityFactor * 0.01; // Slight upward movement (panic)
                }
            }
            
            // Handle Train Rush camera (View #18)
            if (camera.userData.isTrainRush && trainCars.length > 0) {
                // Get the locomotive position
                const loco = trainCars[0];
                const locoPath = trainPathCurve.getPoint(loco.u);
                
                // Calculate the angle to position camera ahead of train
                const locoAngle = Math.atan2(locoPath.y, locoPath.x);
                const lookAheadDistance = 5; // How far ahead on track
                const lookAheadAngle = locoAngle - (lookAheadDistance / simParams.trackRadius);
                
                // Position camera on track ahead of locomotive
                camera.position.set(
                    Math.cos(lookAheadAngle) * simParams.trackRadius,
                    0.3, // Very low on track
                    Math.sin(lookAheadAngle) * simParams.trackRadius
                );
                
                // Look directly at the locomotive
                camera.lookAt(new THREE.Vector3(
                    locoPath.x,
                    1.8, // Look up at the front of the locomotive
                    locoPath.y
                ));
                
                // Add subtle shake to emulate vintage hand-held camera
                const shakeAmount = 0.01;
                camera.position.x += (Math.random() - 0.5) * shakeAmount;
                camera.position.y += (Math.random() - 0.5) * shakeAmount;
                camera.position.z += (Math.random() - 0.5) * shakeAmount;
            }

            controls.update(); 
            renderer.render(scene, camera);
        }

        // Initialize the scene
        init();
    </script>
</body>
</html>