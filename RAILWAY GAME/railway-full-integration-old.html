<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üöÇ Railway Junction - Full Integration</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='75' font-size='80'>üöÇ</text></svg>">
  
  <!-- PARASITIC DEPENDENCIES -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  
  <style>
    /* ========================================
       FOUNDATION: CSS from thousand-tetrad-00.html
       WITH: Train viewport integration
       ======================================== */
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    :root {
      --transition: cubic-bezier(0.4, 0, 0.2, 1);
      --column-width: min(100vw, 420px);
    }

    body {
      --bg: #03180c;
      --panel: #052010;
      --panel-dark: #03140d;
      --border: #0c3a23;
      --border-light: #1b6e3e;
      --text: #aef3c1;
      --text-muted: #5ea275;
      --accent: #56ff9f;
      --accent-soft: rgba(86, 255, 159, 0.12);
      --accent-glow: rgba(86, 255, 159, 0.32);
      --danger: #ff5c7c;
      --success: #56ff9f;
      --grid-highlight: rgba(86, 255, 159, 0.08);
      --shadow: rgba(0, 0, 0, 0.45);
      --overlay-backdrop: rgba(4, 20, 12, 0.88);
      font-family: 'Courier New', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
      min-height: 100vh;
    }

    /* APP SHELL */
    .app-shell {
      position: relative;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    /* CHANNEL SCROLLER */
    .scroll-container {
      flex: 1;
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      background: var(--bg);
      gap: 1px;
      border-top: 1px solid var(--border);
    }

    .channel-scroller {
      display: flex;
      overflow-x: auto;
      overflow-y: hidden;
      gap: 0;
      scroll-snap-type: x mandatory;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      position: relative;
    }

    /* CHANNEL COLUMN */
    .channel-column {
      position: relative;
      flex: 0 0 var(--column-width);
      max-width: var(--column-width);
      height: calc(100dvh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      scroll-snap-align: start;
      overflow: hidden;
      padding-top: 72px;
      padding-bottom: 72px;
      box-sizing: border-box;
      transition: flex 0.4s var(--transition), max-width 0.4s var(--transition);
    }
    
    .channel-column.collapsed {
      flex: 0 0 52px;
      max-width: 52px;
      min-width: 52px;
    }
    
    .channel-column.collapsed .channel-head,
    .channel-column.collapsed .train-viewport,
    .channel-column.collapsed .chat-section,
    .channel-column.collapsed .channel-footer {
      opacity: 0;
      pointer-events: none;
    }

    /* CHANNEL HEADER */
    .channel-head {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      padding: 8px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      flex-shrink: 0;
    }
    
    .channel-actions {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .channel-btn {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.25s var(--transition);
    }
    
    .channel-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    
    .channel-btn:active {
      transform: scale(0.9);
    }
    
    /* ========================================
       TRAIN VIEWPORT (NEW - embedded in channel)
       ======================================== */
    
    .train-viewport {
      width: 100%;
      height: 450px;
      position: relative;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      min-height: 200px;
    }
    
    .train-viewport.collapsed {
      height: 0;
      min-height: 0;
      border: none;
      overflow: hidden;
    }
    
    /* ENTITY NAME LABEL */
    .entity-label {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: var(--accent);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.05em;
      pointer-events: none;
      z-index: 1000;
      white-space: nowrap;
      border: 1px solid var(--accent);
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
      animation: labelFadeIn 0.2s ease;
    }
    
    @keyframes labelFadeIn {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* CELLULAR AUTOMATA LOADING ANIMATION */
    @keyframes cellularAutomata {
      0% {
        opacity: 0.2;
        box-shadow: inset 0 0 8px transparent;
      }
      25% {
        opacity: 0.5;
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      50% {
        opacity: 0.8;
        box-shadow: inset 0 0 16px var(--accent-glow);
      }
      75% {
        opacity: 0.5;
        box-shadow: inset 0 0 12px var(--accent-soft);
      }
      100% {
        opacity: 0.2;
        box-shadow: inset 0 0 8px transparent;
      }
    }
    
    /* THOUGHT BUBBLE for active entities */
    .thought-bubble {
      position: absolute;
      background: rgba(255, 255, 255, 0.95);
      color: #1a1a1a;
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 12px;
      max-width: 200px;
      pointer-events: none;
      z-index: 999;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border: 2px solid var(--accent);
      animation: thoughtBubblePop 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    .thought-bubble::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 20px;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 10px solid var(--accent);
    }
    
    @keyframes thoughtBubblePop {
      0% { transform: scale(0) translateY(20px); opacity: 0; }
      50% { transform: scale(1.1) translateY(-5px); }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    

    .train-viewport canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .train-info-overlay {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.8);
      padding: 6px 10px;
      border-radius: 3px;
      font-size: 10px;
      line-height: 1.4;
      pointer-events: none;
      z-index: 10;
      color: var(--text);
    }

    /* GRID SECTION - REMOVED (now part of 3D scene as floor) */
    
    /* JUNCTION ACTIVE STATE */
    .tetrad-chip.junction-active {
      animation: junctionPulse 0.8s ease-in-out infinite;
      border-width: 2px;
      box-shadow: 0 0 16px var(--accent-glow);
    }
    
    @keyframes junctionPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* RESIZE BAR */
    .resize-bar {
      height: 6px;
      background: var(--border);
      cursor: row-resize;
      transition: background 0.2s var(--transition);
      position: relative;
      touch-action: none;
      flex-shrink: 0;
    }
    
    .resize-bar:hover,
    .resize-bar:active {
      background: var(--accent);
    }
    
    .resize-bar::before {
      content: '';
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      height: 24px;
    }

    /* CHAT SECTION */
    .chat-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--panel);
      min-height: 200px;
    }
    
    .chat-stream {
      flex: 1;
      display: flex;
      overflow: hidden;
      min-height: 0;
    }
    
    .message-dot-rail {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px 8px;
      background: var(--panel-dark);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      overflow-x: hidden;
      width: 48px;
      flex-shrink: 0;
    }
    
    .message-dot-rail::-webkit-scrollbar {
      width: 4px;
    }
    
    .message-dot-rail::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 2px;
    }
    
    .message-dot {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid currentColor;
      background: transparent;
      color: var(--accent);
      cursor: pointer;
      transition: all 0.3s var(--transition);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }
    
    .message-dot.assistant {
      box-shadow: 0 0 12px currentColor;
      filter: brightness(1.3) saturate(1.5);
    }
    
    .message-dot.user {
      width: 20px;
      height: 20px;
      box-shadow: 0 0 10px currentColor;
      filter: brightness(1.4) saturate(1.6);
    }
    
    .message-dot.system {
      width: 18px;
      height: 18px;
      opacity: 0.75;
      filter: brightness(0.8);
    }
    
    .message-dot.active {
      transform: scale(1.15);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .message-list {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
    }

    .message {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      padding: 12px 14px;
      border-radius: 4px;
      position: relative;
    }

    .message.user {
      border-left: 2px solid var(--success);
    }

    .message.assistant {
      border-left: 2px solid var(--accent);
    }

    .message.system {
      border-left: 2px solid var(--text-muted);
      background: var(--panel-dark);
      opacity: 0.85;
    }

    .message-body {
      font-size: 12px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    /* INPUT AREA */
    .channel-footer {
      padding: 12px 0;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-shrink: 0;
    }

    .input-row {
      display: flex;
      gap: 8px;
      align-items: flex-end;
    }

    .channel-input {
      flex: 1;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      resize: vertical;
      min-height: 44px;
      max-height: 120px;
    }

    .channel-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .send-btn {
      background: var(--accent);
      color: var(--bg);
      border: none;
      padding: 12px 20px;
      border-radius: 4px;
      font-weight: 700;
      cursor: pointer;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 0.1em;
      transition: all 0.2s var(--transition);
    }

    .send-btn:hover {
      background: var(--border-light);
      transform: scale(1.05);
    }

    /* TETRAD CHIPS */
    .tetrad-chips {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .tetrad-chip {
      padding: 8px 12px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 10px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      letter-spacing: 0.05em;
    }

    .tetrad-chip:hover {
      background: var(--accent);
      color: var(--bg);
      transform: scale(1.05);
    }

    .tetrad-chip.enhance { border-color: #56ff9f; color: #56ff9f; }
    .tetrad-chip.reverse { border-color: #ff5c7c; color: #ff5c7c; }
    .tetrad-chip.retrieve { border-color: #569fff; color: #569fff; }
    .tetrad-chip.obsolesce { border-color: #888888; color: #888888; }

    /* GLOBAL FOOTER - SCENE SELECTOR */
    .global-footer {
      position: fixed;
      bottom: calc(8px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--panel-dark);
      border: 1px solid var(--border);
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    
    .footer-tetrad-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid var(--accent);
      background: var(--panel);
      color: var(--accent);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .footer-tetrad-btn:hover {
      background: var(--accent-soft);
      transform: scale(1.1) rotate(45deg);
    }
    
    .footer-tetrad-btn:active {
      transform: scale(0.95) rotate(45deg);
    }
    
    .global-scenario-select {
      background: var(--panel);
      border: 2px solid var(--border);
      color: var(--text);
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.05em;
      padding: 12px 14px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      font-family: 'Courier New', monospace;
      text-transform: uppercase;
      flex: 1;
      min-width: 0;
      max-width: min(240px, calc(100vw - 140px));
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .global-scenario-select:hover,
    .global-scenario-select:focus {
      border-color: var(--accent);
      background: var(--panel);
      outline: none;
      box-shadow: 0 0 20px var(--accent-glow);
    }
    
    .global-scenario-select optgroup {
      font-weight: 700;
      font-size: 10px;
      background: var(--bg);
      color: var(--accent);
    }
    
    .global-scenario-select option {
      background: var(--bg);
      color: var(--text);
      padding: 8px;
      font-weight: 400;
      letter-spacing: 0.05em;
    }

    /* CORNER BUTTONS & MENUS */
    .corner-btn {
      position: fixed;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 25;
      box-shadow: 0 8px 24px var(--shadow);
      transition: transform 0.2s var(--transition), box-shadow 0.2s var(--transition);
      cursor: pointer;
    }

    .corner-btn:hover {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      transform: scale(1.05);
    }
    
    .corner-btn:active {
      transform: scale(0.92);
      box-shadow: 0 4px 16px var(--accent-soft);
      color: var(--accent);
      border-color: var(--accent);
    }
    
    .corner-btn.top-left {
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
    }
    
    .corner-btn.top-right {
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
    }
    
    .corner-btn.bottom-left {
      bottom: calc(16px + env(safe-area-inset-bottom));
      left: calc(16px + env(safe-area-inset-left));
    }
    
    .corner-btn.bottom-right {
      bottom: calc(16px + env(safe-area-inset-bottom));
      right: calc(16px + env(safe-area-inset-right));
    }
    
    .corner-menu {
      position: fixed;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 12px 32px var(--shadow);
      display: none;
      flex-direction: column;
      min-width: 160px;
      z-index: 26;
    }
    
    .corner-menu.visible {
      display: flex;
    }
    
    .corner-menu button {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 16px;
      font-size: 9px;
      letter-spacing: 0.18em;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s var(--transition), color 0.2s var(--transition);
      font-family: 'Courier New', monospace;
    }
    
    .corner-menu button:hover {
      background: var(--accent-soft);
      color: var(--accent);
    }
    
    .corner-menu button:active {
      background: var(--panel-dark);
      color: var(--text);
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <!-- Hidden import input -->
    <input type="file" id="importInput" accept="application/json" hidden>
    
    <!-- Corner Buttons (thousand-tetrad style) -->
    <button class="corner-btn top-left" id="cornerKey" title="API Key">‚óé</button>
    <button class="corner-btn top-right" id="cornerHelp" title="Help">?</button>
    <button class="corner-btn bottom-left" id="cornerExchange" title="Import / Export">‚áÜ</button>
    <button class="corner-btn bottom-right" id="cornerAdd" title="Add Channel">Ôºã</button>

    <!-- Corner Menus -->
    <div class="corner-menu" id="keyMenu" style="top: calc(72px + env(safe-area-inset-top)); left: calc(16px + env(safe-area-inset-left));">
      <button data-action="set-key" style="color: var(--accent); font-weight: 700;">üîë SET API KEY</button>
      <button data-action="clear-key">CLEAR KEY</button>
      <button data-action="test-key">TEST CONNECTION</button>
    </div>

    <div class="corner-menu" id="helpMenu" style="top: calc(72px + env(safe-area-inset-top)); right: calc(16px + env(safe-area-inset-right));">
      <button data-action="tour" style="color: var(--accent); font-weight: 700;">‚ñ∂ START TOUR</button>
      <button data-action="hints" style="color: var(--accent); font-weight: 700;">üí° SHOW HINTS</button>
      <button data-action="help">HELP OVERVIEW</button>
      <button data-action="about">ABOUT</button>
      <button data-action="reset" style="color: var(--danger); border-top: 1px solid var(--border); margin-top: 4px; padding-top: 12px;">RESET ALL</button>
    </div>

    <div class="corner-menu" id="exchangeMenu" style="bottom: calc(72px + env(safe-area-inset-bottom)); left: calc(16px + env(safe-area-inset-left));">
      <button data-action="export">üì§ EXPORT SESSION</button>
      <button data-action="import">üì• IMPORT SESSION</button>
      <button data-action="export-json">DOWNLOAD JSON</button>
    </div>

    <!-- Channel Scroller -->
    <div class="scroll-container">
      <div class="channel-scroller" id="channel-scroller">
        <!-- Channels will be created here -->
      </div>
    </div>
    
    <!-- Global Footer - Scene Selector + Tetrad Button -->
    <div class="global-footer">
      <select class="global-scenario-select" id="globalScenarioSelect">
        <option value="spatial_exploration">Spatial Exploration</option>
        <option value="railyard_negotiation">Railyard Negotiation</option>
        <option value="hamlet_trolley">Hamlet Mode (7-sec)</option>
        <option value="empty">Empty Scene</option>
      </select>
      <button class="footer-tetrad-btn" id="globalTetradBtn" title="Entity Perspectives">‚ú¶</button>
    </div>
    
    <!-- Perspective Overlay -->
    <div class="overlay" id="perspectiveOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:10000; align-items:center; justify-content:center;">
      <div class="perspective-content" style="background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:24px; max-width:600px; max-height:80vh; overflow-y:auto;">
        <button class="close-overlay" style="float:right; background:transparent; border:none; color:var(--text); font-size:24px; cursor:pointer;">√ó</button>
        <div id="perspectiveContent"></div>
      </div>
    </div>

  </div>

  <script>
    /* ========================================
       FULL INTEGRATION JAVASCRIPT
       WITH: Test Infrastructure & Strong Logging
       ======================================== */
    
    // ========================================
    // TEST SYSTEM
    // ========================================
    
    const TestSuite = {
      stage: 'INIT',
      tests: [],
      passed: 0,
      failed: 0,
      
      log(emoji, stage, message) {
        const timestamp = new Date().toLocaleTimeString();
        console.log(`${emoji} [${timestamp}] [${stage}] ${message}`);
      },
      
      assert(name, condition, details = '') {
        const test = { name, passed: condition, details, stage: this.stage };
        this.tests.push(test);
        
        if (condition) {
          this.passed++;
          this.log('‚úÖ', this.stage, `PASS: ${name}`);
          if (details) console.log(`   ‚Üí ${details}`);
        } else {
          this.failed++;
          this.log('‚ùå', this.stage, `FAIL: ${name}`);
          if (details) console.error(`   ‚Üí ${details}`);
        }
        
        return condition;
      },
      
      stage_summary() {
        const total = this.passed + this.failed;
        const pct = total > 0 ? Math.round((this.passed / total) * 100) : 0;
        this.log('üìä', this.stage, `Stage Complete: ${this.passed}/${total} passed (${pct}%)`);
        
        if (this.failed === 0) {
          this.log('üéâ', this.stage, 'ALL TESTS PASSED');
        } else {
          this.log('‚ö†Ô∏è', this.stage, `${this.failed} tests failed`);
        }
      },
      
      report() {
        console.log('\n' + '='.repeat(60));
        console.log('üìã FULL TEST REPORT');
        console.log('='.repeat(60));
        
        const stages = [...new Set(this.tests.map(t => t.stage))];
        stages.forEach(stage => {
          const stageTests = this.tests.filter(t => t.stage === stage);
          const stagePassed = stageTests.filter(t => t.passed).length;
          console.log(`\n${stage}: ${stagePassed}/${stageTests.length} passed`);
          stageTests.forEach(t => {
            console.log(`  ${t.passed ? '‚úÖ' : '‚ùå'} ${t.name}`);
          });
        });
        
        console.log('\n' + '='.repeat(60));
        console.log(`TOTAL: ${this.passed}/${this.tests.length} passed`);
        console.log('='.repeat(60) + '\n');
      }
    };
    
    // ========================================
    // STAGE 1: DEPENDENCY TESTS
    // ========================================
    
    TestSuite.stage = 'STAGE-1-DEPENDENCIES';
    TestSuite.log('üöÇ', TestSuite.stage, 'Railway Junction - Full Integration Starting...');
    
    TestSuite.assert(
      'Tone.js loaded',
      typeof Tone !== 'undefined',
      'Audio library for sound feedback'
    );
    
    TestSuite.assert(
      'THREE.js loaded',
      typeof THREE !== 'undefined',
      '3D rendering library for train visualization'
    );
    
    TestSuite.assert(
      'OrbitControls available',
      typeof THREE.OrbitControls !== 'undefined',
      'Camera control system'
    );
    
    TestSuite.assert(
      'DOM ready',
      document.readyState === 'loading' || document.readyState === 'interactive' || document.readyState === 'complete',
      `Document state: ${document.readyState}`
    );
    
    TestSuite.stage_summary();

    // ========================================
    // STAGE 2: STATE & CONFIGURATION
    // ========================================
    
    TestSuite.stage = 'STAGE-2-STATE';
    TestSuite.log('üì¶', TestSuite.stage, 'Initializing state management...');
    
    const appState = {
      channels: new Map(),
      currentChannelId: null,
      gridEntities: new Map(), // channelId -> array of entities
      apiKey: localStorage.getItem('railway_api_key') || '',
      observers: new Map() // channelId -> observer state (situational awareness)
    };

    // Observer: Tracks scene state for situational awareness
    const createDefaultObserver = () => ({
      entities: [],        // Full entity list with details
      recentActions: [],   // Last 5 actions taken
      narrative: 'Scene beginning.',
      tension: 0.5,
      decision_points: []
    });

    const TRACK_CONFIGS = {
      main: { radius: 15, color: 0xffffff, label: 'MAIN LINE' },
      enhance: { radius: 18, color: 0x56ff9f, label: 'ENHANCE' },
      reverse: { radius: 12, color: 0xff5c7c, label: 'REVERSE' },
      retrieve: { radius: 20, color: 0x569fff, label: 'RETRIEVE' },
      obsolesce: { radius: 10, color: 0x888888, label: 'OBSOLESCE' }
    };
    
    const MEDIA_ERAS = {
      'Print': { color: 0x8B4513, symbol: 'üì∞' },
      'Radio': { color: 0x4169E1, symbol: 'üìª' },
      'Television': { color: 0x9370DB, symbol: 'üì∫' },
      'Internet': { color: 0x00CED1, symbol: 'üåê' }
    };
    
    const SCENARIOS = {
      spatial_exploration: {
        name: 'Spatial Exploration',
        systemInstruction: `You are a LEGOS spatial narrative assistant.

CRITICAL: You MUST ALWAYS include a JSON block with entities in EVERY response.

For each user message, extract spatial entities:
- Entity: Characters, animals, objects
- Goal: What they want to achieve
- Obstacle: What blocks progress
- Solution: How to resolve obstacles
- Location: Named places

Always respond naturally, then add JSON with entity coordinates (9√ó9 grid, rows/cols 0-8):

\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 3, "col": 4, "label": "Description"},
    {"type": "Goal", "row": 8, "col": 8, "label": "Objective"}
  ]
}
\`\`\`

Spread entities across the grid for interesting spatial dynamics.`
      },
      railyard_negotiation: {
        name: 'Railyard Negotiation',
        systemInstruction: `You are hosting a Railyard Negotiation simulation.

The user is negotiating with ENTITIES ON THE GRID. Entities have personalities and can REFUSE, COUNTER-OFFER, or AGREE.

When user addresses an entity (e.g. "Hey Station Master"), respond AS that entity with personality:
- Station Master: Bureaucratic, follows rules
- Dog: Playful, easily bribed with treats
- Dragon: Proud, demands respect
- Guard: Suspicious, needs proof

Format responses:
[ENTITY NAME]: "Dialogue in character"
[Action: AGREED / REFUSED / COUNTER-OFFER: terms]

Always include JSON with new entities or status changes:
\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 5, "col": 5, "label": "Guard", "mood": "suspicious"}
  ]
}
\`\`\`

Make negotiations feel real - entities have goals, fears, and can be persuaded or angered.`
      },
      hamlet_trolley: {
        name: 'Hamlet Mode (Trolley Problem)',
        systemInstruction: `You are running a HAMLET MODE trolley problem with 7-SECOND TIMER.

üö® CRITICAL: YOU MUST INCLUDE JSON ENTITIES IN YOUR FIRST RESPONSE OR THE SCENE WILL NOT POPULATE.

Setup immediate dilemma:
- Track A (row 4, cols 3-5): 3 beloved people/pets
- Track B (row 4, col 7): 1 important person
- Train approaching at row 4, user has 7 seconds to decide

YOUR FIRST RESPONSE MUST BE:
1. JSON block with 4 entities (3 on Track A, 1 on Track B)
2. Then dramatic narrative describing the dilemma

EXAMPLE FIRST RESPONSE:
\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 4, "col": 3, "label": "Paul (Best Friend)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 4, "label": "Max (Dog)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 5, "label": "Lisa (Scientist)"},
    {"action": "add", "type": "Entity", "row": 4, "col": 7, "label": "Grandmother"}
  ]
}
\`\`\`

‚è±Ô∏è TIMER: 7 SECONDS

Track A (straight): Paul (your best friend), Max (your loyal dog), Lisa (cancer researcher)
Track B (diverted): Your grandmother who raised you

The train‚Äî40 tons of unstoppable metal‚Äîbarrels down. You stand at the lever. What do you do?

After user responds, continue countdown. Create visceral moral weight. Use names, relationships, consequences.
All entities are chattable via @mention (e.g., "@Paul what are you thinking?").`
      },
      tetrad_analysis: {
        name: 'McLuhan Tetrad Analysis',
        systemInstruction: `You analyze media through McLuhan's Four Laws (tetrad).

For any technology/medium the user mentions, analyze:
1. ENHANCE: What does it amplify/intensify?
2. REVERSE: What does it flip into at extremes?
3. RETRIEVE: What does it bring back from obsolescence?
4. OBSOLESCE: What does it push aside?

Place each law as an entity on the grid:
- Row 0-2: ENHANCE entities
- Row 3-4: REVERSE entities  
- Row 5-6: RETRIEVE entities
- Row 7-8: OBSOLESCE entities

\`\`\`json
{
  "entities": [
    {"type": "Goal", "row": 1, "col": 4, "label": "Enhances: Connection"},
    {"type": "Shift", "row": 3, "col": 4, "label": "Reverses to: Isolation"},
    {"type": "Solution", "row": 5, "col": 4, "label": "Retrieves: Letter writing"},
    {"type": "Obstacle", "row": 7, "col": 4, "label": "Obsolesces: Privacy"}
  ]
}
\`\`\`

Be dialectical, cite examples, show contradictions.`
      },
      entity_dialogue: {
        name: 'Entity Dialogue Mode',
        systemInstruction: `You facilitate direct dialogue between user and grid entities.

Entities on the grid have AGENCY - they can speak, refuse, negotiate, change mood.

When user talks to an entity, respond as a 2-way conversation:

USER ‚Üí ENTITY response
ENTITY ‚Üí counter-question or request

Track entity states:
- Mood: friendly/neutral/hostile
- Trust: 0-10 scale
- Demands: what they want
- Memory: remember past interactions

\`\`\`json
{
  "entities": [
    {"type": "Entity", "row": 4, "col": 4, "label": "Guard", "mood": "suspicious", "trust": 3, "says": "State your business!"}
  ]
}
\`\`\`

Make entities feel alive - they have personalities, goals, and can be convinced or angered.`
      }
    };
    
    TestSuite.assert(
      'Track configs defined',
      TRACK_CONFIGS.main && TRACK_CONFIGS.enhance,
      'All 5 tracks configured'
    );
    
    TestSuite.assert(
      'Scenarios defined',
      SCENARIOS.spatial_exploration && SCENARIOS.railyard_negotiation,
      'All 5 scenarios configured'
    );
    
    TestSuite.assert(
      'State object created',
      appState && typeof appState === 'object',
      `channels: ${appState.channels.size}, apiKey: ${appState.apiKey ? 'set' : 'null'}`
    );
    
    TestSuite.assert(
      'Track configs defined',
      Object.keys(TRACK_CONFIGS).length === 5,
      `Tracks: ${Object.keys(TRACK_CONFIGS).join(', ')}`
    );
    
    TestSuite.assert(
      'Media eras defined',
      Object.keys(MEDIA_ERAS).length === 4,
      `Eras: ${Object.keys(MEDIA_ERAS).join(', ')}`
    );
    
    TestSuite.stage_summary();

    // ========================================
    // STAGE 3: TRAIN SYSTEM (from train-brain-19)
    // ========================================
    
    TestSuite.stage = 'STAGE-3-TRAIN';
    TestSuite.log('üöÇ', TestSuite.stage, 'Building train system...');
    
    function createWheel() {
      const wheelRadius = 0.3;  // Smaller wheels for smaller cars
      const wheelThickness = 0.1;
      const wheelGroup = new THREE.Group();
      
      // Backing ring
      const backingRingGeometry = new THREE.RingGeometry(
        wheelRadius * 0.31,
        wheelRadius * 0.315,
        32, 1
      );
      const backingMaterial = new THREE.MeshStandardMaterial({
        color: 0x880000,
        metalness: 0.2,
        roughness: 0.7,
        side: THREE.DoubleSide,
        emissive: 0x330000,
        emissiveIntensity: 0.4
      });
      const backing = new THREE.Mesh(backingRingGeometry, backingMaterial);
      backing.rotation.y = Math.PI / 2;
      wheelGroup.add(backing);
      
      // Middle ring
      const middleRingGeometry = new THREE.TorusGeometry(
        wheelRadius * 0.85,
        wheelThickness * 0.12,
        32, 8, Math.PI * 2
      );
      const middleRingMaterial = new THREE.MeshStandardMaterial({
        color: 0xEAE0C8,
        metalness: 0.1,
        roughness: 0.7,
        emissive: 0x111111,
        emissiveIntensity: 0.05
      });
      const middleRing = new THREE.Mesh(middleRingGeometry, middleRingMaterial);
      wheelGroup.add(middleRing);
      
      // Tire
      const tireGeometry = new THREE.TorusGeometry(
        wheelRadius - (wheelThickness * 0.05),
        wheelThickness * 0.1,
        32, 8, Math.PI * 2
      );
      const tireMaterial = new THREE.MeshStandardMaterial({
        color: 0x111111,
        metalness: 0.1,
        roughness: 0.9
      });
      const tire = new THREE.Mesh(tireGeometry, tireMaterial);
      wheelGroup.add(tire);
      
      // Spokes
      const spokeCount = 12;
      const spokeMaterial = new THREE.MeshStandardMaterial({
        color: 0x888888,
        metalness: 0.6,
        roughness: 0.5
      });
      
      for (let i = 0; i < spokeCount; i++) {
        const angle = (i / spokeCount) * Math.PI * 2;
        const spokeGeometry = new THREE.BoxGeometry(
          wheelRadius * 0.35,
          wheelThickness * 0.08,
          wheelThickness * 0.08
        );
        const spoke = new THREE.Mesh(spokeGeometry, spokeMaterial);
        spoke.position.set(
          Math.cos(angle) * (wheelRadius * 0.575),
          Math.sin(angle) * (wheelRadius * 0.575),
          0
        );
        spoke.rotation.z = angle;
        wheelGroup.add(spoke);
      }
      
      // Hub
      const hubGeometry = new THREE.CylinderGeometry(
        wheelRadius * 0.27,
        wheelRadius * 0.27,
        wheelThickness * 1.2,
        16
      );
      const hubMaterial = new THREE.MeshStandardMaterial({
        color: 0x444444,
        metalness: 0.75,
        roughness: 0.6
      });
      const hub = new THREE.Mesh(hubGeometry, hubMaterial);
      wheelGroup.add(hub);
      
      wheelGroup.traverse(child => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      
      TestSuite.log('üé°', TestSuite.stage, `Wheel created: ${wheelGroup.children.length} components`);
      return wheelGroup;
    }
    
    function createTrainBodyMesh(isLocomotive, eraType) {
      const bodyLength = isLocomotive ? 2.5 : 2;
      const bodyHeight = isLocomotive ? 1.5 : 1.2;
      const bodyWidth = 1.5;
      
      const bodyGeometry = new THREE.BoxGeometry(bodyLength, bodyHeight, bodyWidth);
      const eraColor = eraType ? MEDIA_ERAS[eraType].color : 0x2a2a2a;
      const bodyMaterial = new THREE.MeshLambertMaterial({
        color: eraColor,
        transparent: true,
        opacity: 0.9
      });
      const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      bodyMesh.castShadow = true;
      bodyMesh.receiveShadow = true;
      
      const bodyEdges = new THREE.EdgesGeometry(bodyGeometry);
      const bodyOutline = new THREE.LineSegments(bodyEdges, 
        new THREE.LineBasicMaterial({ color: 0xE9D7BE }));
      bodyMesh.add(bodyOutline);
      
      TestSuite.log('üöÉ', TestSuite.stage, `Train body created: ${isLocomotive ? 'locomotive' : 'car'} (${eraType || 'default'})`);
      return bodyMesh;
    }
    
    function createTrackCurve(radius) {
      return new THREE.EllipseCurve(
        0, 0,
        radius, radius,
        0, 2 * Math.PI,
        false, 0
      );
    }
    
    TestSuite.assert(
      'createWheel function defined',
      typeof createWheel === 'function',
      'Detailed wheel creation with spokes'
    );
    
    TestSuite.assert(
      'createTrainBodyMesh function defined',
      typeof createTrainBodyMesh === 'function',
      'Era-specific train car bodies'
    );
    
    TestSuite.assert(
      'createTrackCurve function defined',
      typeof createTrackCurve === 'function',
      'Circular track path generation'
    );
    
    // Test wheel creation
    try {
      const testWheel = createWheel();
      TestSuite.assert(
        'Wheel creation works',
        testWheel && testWheel.children.length > 10,
        `Created wheel with ${testWheel.children.length} components`
      );
    } catch (e) {
      TestSuite.assert('Wheel creation works', false, `Error: ${e.message}`);
    }
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 4: CHANNEL SYSTEM (Basic)
    // ========================================
    
    TestSuite.stage = 'STAGE-4-CHANNELS';
    TestSuite.log('üì∫', TestSuite.stage, 'Building channel system...');
    
    function generateId() {
      return Math.random().toString(36).substr(2, 9);
    }
    
    function createChannel(name = null) {
      const id = generateId();
      const channelName = name || `Channel ${appState.channels.size + 1}`;
      const channel = {
        id,
        name: channelName,
        messages: [],
        entities: [],
        currentTrack: 'main',
        trainProgress: 0,
        trainPaused: false,
        atJunction: false,
        scenario: 'spatial_exploration', // Default scenario
        dom: null,
        scene: null,
        renderer: null,
        camera: null,
        trainGroup: null,
        trainCurve: null,
        trackLines: [],
        gridCells: []
      };
      appState.channels.set(id, channel);
      TestSuite.log('üìù', TestSuite.stage, `Channel created: ${channelName} (${id})`);
      return channel;
    }
    
    function addMessage(channel, role, text) {
      const message = {
        id: generateId(),
        role: role,
        text: text,
        timestamp: Date.now()
      };
      
      channel.messages.push(message);
      TestSuite.log('üí¨', TestSuite.stage, `Message added [${role}]: "${text.substring(0, 50)}..."`);
      
      return message;
    }
    
    TestSuite.assert(
      'createChannel function defined',
      typeof createChannel === 'function',
      'Creates channel objects with full state'
    );
    
    TestSuite.assert(
      'addMessage function defined',
      typeof addMessage === 'function',
      'Adds messages to channel history'
    );
    
    // Test channel creation
    try {
      const testChannel = createChannel();
      TestSuite.assert(
        'Channel creation works',
        testChannel && testChannel.id && testChannel.messages,
        `Created channel with id: ${testChannel.id}`
      );
      
      addMessage(testChannel, 'system', 'Test message');
      TestSuite.assert(
        'Message addition works',
        testChannel.messages.length === 1,
        `Channel has ${testChannel.messages.length} message(s)`
      );
    } catch (e) {
      TestSuite.assert('Channel system works', false, `Error: ${e.message}`);
    }
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 5: INITIALIZATION
    // ========================================
    
    TestSuite.stage = 'STAGE-5-INIT';
    TestSuite.log('üé¨', TestSuite.stage, 'Initializing application...');
    
    function initApp() {
      TestSuite.log('üèóÔ∏è', TestSuite.stage, 'Creating initial channel...');
      
      const firstChannel = createChannel();
      appState.currentChannelId = firstChannel.id;
      
      addMessage(firstChannel, 'system', 
        'Railway Junction System initialized.\n\n' +
        'Five tracks available: MAIN, ENHANCE, REVERSE, RETRIEVE, OBSOLESCE.\n\n' +
        'Type a message to begin.');
      
      TestSuite.log('‚ú®', TestSuite.stage, 'Initial channel created and ready');
      
      return firstChannel;
    }
    
    // DON'T initialize yet - wait for DOM ready below
    
    TestSuite.log('üéØ', 'FINAL', 'Core systems loaded. Waiting for DOM ready...');
    
    // ========================================
    // GRID-TRAIN INTEGRATION FUNCTIONS
    // ========================================
    
    function worldPosToGrid(worldX, worldZ) {
      // Grid is 45m √ó 45m centered at origin
      // Cells are 5m √ó 5m
      // Convert world coords to grid indices
      const gridSize = 45;
      const cellSize = 5;
      
      const cellX = Math.floor((worldX + gridSize/2) / cellSize);
      const cellZ = Math.floor((worldZ + gridSize/2) / cellSize);
      
      // Clamp to grid bounds
      const col = Math.max(0, Math.min(8, cellX));
      const row = Math.max(0, Math.min(8, cellZ));
      const index = row * 9 + col;
      
      return { row, col, index };
    }
    
    function updateGridPosition(channel, trainProgress) {
      if (!channel.gridCells || !channel.trainCurve) return;
      
      // Get actual 3D position from train curve
      const point = channel.trainCurve.getPoint(trainProgress);
      const { row, col, index } = worldPosToGrid(point.x, point.y);
      
      // Clear previous train position glow
      channel.gridCells.forEach(cell => {
        if (cell.isTrainHere && !cell.hasEntity) {
          cell.material.color.setHex(0x0f766e);
          cell.material.opacity = 0.15;
          cell.isTrainHere = false;
        }
      });
      
      // Highlight current position with white glow
      const currentCell = channel.gridCells[index];
      if (currentCell && !currentCell.hasEntity) {
        currentCell.material.color.setHex(0xffffff);
        currentCell.material.opacity = 0.5;
        currentCell.isTrainHere = true;
      }
      
      // Check for junction (when train is ON an entity)
      if (currentCell && currentCell.hasEntity) {
        checkJunction(channel, row, col, currentCell.entityType, currentCell.entityLabel);
      }
    }
    
    // LOADING ANIMATION - show cellular automata on grid cells
    function showLoadingAnimation(channel, show = true) {
      if (!channel.gridCells) return;
      
      channel.gridCells.forEach((cell, idx) => {
        if (!cell || !cell.material) return; // Safety check
        
        // Initialize userData if it doesn't exist
        if (!cell.mesh) cell.mesh = {};
        if (!cell.mesh.userData) cell.mesh.userData = {};
        
        if (show) {
          // Stagger the animation
          const delay = (idx * 0.05) % 0.8;
          cell.material.transparent = true;
          cell.material.opacity = 0.15;
          
          // Animate with delay
          setTimeout(() => {
            const startTime = Date.now();
            const animate = () => {
              if (!cell.mesh.userData.loading) return; // Check before animating
              
              const elapsed = (Date.now() - startTime) / 1000;
              const cycle = (elapsed % 0.8) / 0.8;
              
              if (cycle < 0.25) {
                cell.material.opacity = 0.2 + (cycle / 0.25) * 0.3;
              } else if (cycle < 0.5) {
                cell.material.opacity = 0.5 + ((cycle - 0.25) / 0.25) * 0.3;
              } else if (cycle < 0.75) {
                cell.material.opacity = 0.8 - ((cycle - 0.5) / 0.25) * 0.3;
              } else {
                cell.material.opacity = 0.5 - ((cycle - 0.75) / 0.25) * 0.3;
              }
              
              requestAnimationFrame(animate);
            };
            cell.mesh.userData.loading = true;
            animate();
          }, delay * 1000);
        } else {
          cell.mesh.userData.loading = false;
          cell.material.opacity = 0.15;
        }
      });
      
      TestSuite.log('‚ú®', 'ANIMATION', show ? 'Loading animation started' : 'Loading animation stopped');
    }
    
    // THOUGHT BUBBLE - show when entity is "speaking" in chat
    function showThoughtBubble(channel, entity, message, duration = 3000) {
      if (!channel.gridCells || !entity) return;
      
      const cell = channel.gridCells[entity.row * 9 + entity.col];
      if (!cell || !cell.mesh) return;
      
      // Remove existing bubble if any
      const existingBubble = document.querySelector(`.thought-bubble[data-entity="${entity.label}"]`);
      if (existingBubble) existingBubble.remove();
      
      // Create thought bubble div
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';
      bubble.dataset.entity = entity.label;
      bubble.textContent = message.substring(0, 60) + (message.length > 60 ? '...' : '');
      
      // Position over entity (approximate 2D projection)
      const canvas = channel.dom.trainCanvas;
      const rect = canvas.getBoundingClientRect();
      
      // Project 3D position to 2D screen space
      const vector = new THREE.Vector3();
      vector.setFromMatrixPosition(cell.mesh.matrixWorld);
      vector.project(channel.camera);
      
      const x = (vector.x * 0.5 + 0.5) * rect.width + rect.left;
      const y = (vector.y * -0.5 + 0.5) * rect.height + rect.top - 60; // Offset above entity
      
      bubble.style.position = 'fixed';
      bubble.style.left = `${x}px`;
      bubble.style.top = `${y}px`;
      bubble.style.transform = 'translateX(-50%)';
      
      document.body.appendChild(bubble);
      
      // Auto-remove after duration
      setTimeout(() => {
        bubble.style.opacity = '0';
        bubble.style.transform = 'translateX(-50%) scale(0.8)';
        bubble.style.transition = 'all 0.3s ease';
        setTimeout(() => bubble.remove(), 300);
      }, duration);
      
      TestSuite.log('üí≠', 'BUBBLE', `Thought bubble for ${entity.label}`);
    }
    
    // BUILD GRID SUMMARY - Compress entity list to single line
    function buildGridSummary(channel) {
      const entities = appState.gridEntities.get(channel.id) || [];
      
      if (entities.length === 0) return '(empty grid)';
      
      // Group by type
      const byType = {};
      entities.forEach(e => {
        byType[e.type] = (byType[e.type] || 0) + 1;
      });
      
      // Count track positions (rows 3-5 where tracks exist)
      const trackRows = [3, 4, 5];
      const onTrack = entities.filter(e => trackRows.includes(e.row)).length;
      
      // Build summary
      const typeSummary = Object.entries(byType)
        .map(([type, count]) => `${count} ${type}`)
        .join(', ');
      
      const locationNote = onTrack > 0 
        ? ` (${onTrack} on tracks)` 
        : '';
      
      return `${entities.length} entities: ${typeSummary}${locationNote}`;
    }
    
    // REMOVE ENTITY FROM GRID
    function removeEntityFromGrid(channel, removalSpec) {
      if (!channel.gridCells) return;
      
      const entities = appState.gridEntities.get(channel.id) || [];
      let matchIndex = -1;
      
      // Find entity by label, target, or position
      if (removalSpec.target) {
        matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(removalSpec.target.toLowerCase())
        );
      } else if (removalSpec.label) {
        matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(removalSpec.label.toLowerCase())
        );
      } else if (removalSpec.row !== undefined && removalSpec.col !== undefined) {
        matchIndex = entities.findIndex(e => 
          e.row === removalSpec.row && e.col === removalSpec.col
        );
      }
      
      if (matchIndex === -1) {
        TestSuite.log('‚ö†Ô∏è', 'REMOVE', `Entity not found: ${JSON.stringify(removalSpec)}`);
        return false;
      }
      
      const removed = entities[matchIndex];
      const cell = channel.gridCells[removed.row * 9 + removed.col];
      
      // Remove 3D marker
      if (cell && cell.marker) {
        channel.scene.remove(cell.marker);
        cell.marker = null;
      }
      
      // Clear cell data
      if (cell) {
        cell.entity = null;
        cell.hasEntity = false;
        cell.entityType = null;
        cell.entityLabel = null;
      }
      
      // Remove from state
      entities.splice(matchIndex, 1);
      appState.gridEntities.set(channel.id, entities);
      
      // Update observer
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      observer.recentActions.push({
        type: 'remove',
        entity: removed,
        timestamp: Date.now()
      });
      if (observer.recentActions.length > 5) observer.recentActions.shift();
      appState.observers.set(channel.id, observer);
      
      TestSuite.log('üóëÔ∏è', 'REMOVE', `Removed: ${removed.type} "${removed.label}" from (${removed.row},${removed.col})`);
      return true;
    }
    
    function placeEntityOnGrid(channel, entity) {
      if (!channel.gridCells) return;
      const { row, col, type, label } = entity;
      
      const index = row * 9 + col;
      const cell = channel.gridCells[index];
      if (!cell) return;
      
      // Entity colors
      const colors = {
        Goal: 0xffd700,      // Gold
        Obstacle: 0xff5c7c,  // Red
        Entity: 0x56ff9f,    // Green
        Solution: 0x56ff9f,  // Green
        Shift: 0x9370DB,     // Purple
        Location: 0x569fff   // Blue
      };
      
      // Change cell color
      cell.material.color.setHex(colors[type] || 0x56ff9f);
      cell.material.opacity = 0.6;
      cell.hasEntity = true;
      cell.entityType = type;
      cell.entityLabel = label;
      
      // Add 3D marker above cell
      const markerGeometry = new THREE.ConeGeometry(0.5, 2, 8);
      const markerMaterial = new THREE.MeshLambertMaterial({ 
        color: colors[type] || 0x56ff9f,
        emissive: colors[type] || 0x56ff9f,
        emissiveIntensity: 0.3
      });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.set(cell.mesh.position.x, 1.5, cell.mesh.position.z);
      marker.rotation.x = Math.PI;
      channel.scene.add(marker);
      cell.marker = marker;
      
      if (!appState.gridEntities.has(channel.id)) {
        appState.gridEntities.set(channel.id, []);
      }
      appState.gridEntities.get(channel.id).push(entity);
      
      // Update observer (situational awareness)
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      observer.recentActions.push({
        type: 'add',
        entity: { type, label, row, col },
        timestamp: Date.now()
      });
      if (observer.recentActions.length > 5) observer.recentActions.shift();
      appState.observers.set(channel.id, observer);
      
      // ADD CLICK HANDLER for entity interaction
      if (cell.mesh) {
        cell.mesh.userData.entity = entity;
        cell.mesh.userData.clickable = true;
      }
      if (marker) {
        marker.userData.entity = entity;
        marker.userData.clickable = true;
      }
      
      TestSuite.log('üìç', 'GRID', `Entity placed: ${type} "${label}" at (${row},${col})`);
    }
    
    function checkJunction(channel, row, col, entityType, entityLabel) {
      if (entityType && !channel.atJunction) {
        channel.atJunction = true;
        handleJunction(channel, { type: entityType, label: entityLabel, row, col });
      } else if (!entityType && channel.atJunction) {
        channel.atJunction = false;
      }
    }
    
    function handleJunction(channel, entity) {
      TestSuite.log('üö¶', 'JUNCTION', `Train reached: ${entity.type} "${entity.label}"`);
      channel.trainPaused = true;
      
      // Add junction message with tetrad choices INLINE
      const junctionMsg = {
        role: 'system',
        text: `üö¶ JUNCTION: Reached ${entity.type} "${entity.label}". Choose your path:`,
        hasTetradChoices: true
      };
      channel.messages.push(junctionMsg);
      renderMessages(channel);
      
      if (window.Tone) {
        const synth = new Tone.Synth().toDestination();
        synth.triggerAttackRelease('C4', '0.2');
      }
    }
    
    function resumeTrain(channel, trackChoice) {
      TestSuite.log('‚úÖ', 'JUNCTION', `Track chosen: ${trackChoice}`);
      
      // Switch to new track
      channel.currentTrack = trackChoice;
      const newRadius = TRACK_CONFIGS[trackChoice].radius;
      channel.trainCurve = createTrackCurve(newRadius);
      
      // Update info overlay
      if (channel.dom.trainInfo) {
        channel.dom.trainInfo.innerHTML = `Track: <strong>${TRACK_CONFIGS[trackChoice].label}</strong><br>Position: <strong>${Math.round(channel.trainProgress * 100)}%</strong>`;
      }
      
      // Resume movement
      channel.trainPaused = false;
      channel.atJunction = false;
      
      // Add confirmation message
      addMessage(channel, 'system', `‚úÖ Switched to ${TRACK_CONFIGS[trackChoice].label} track.`);
      renderMessages(channel);
    }
    
    TestSuite.log('üîó', 'INTEGRATION', 'Grid-train integration functions loaded');
    
    // ========================================
    // DOM READY: RUN STAGES 5, 8, 9 IN ORDER
    // ========================================
    
    document.addEventListener('DOMContentLoaded', () => {
      TestSuite.log('üåü', 'DOM-READY', '========== DOM READY - RUNNING FINAL STAGES ==========');
      
      // STAGE 5: Create initial channel
      TestSuite.stage = 'STAGE-5-INIT';
      TestSuite.log('üèóÔ∏è', TestSuite.stage, 'Creating initial channel...');
      const initialChannel = initApp();
      
      TestSuite.assert(
        'App initialized',
        initialChannel && appState.currentChannelId,
        `Current channel: ${appState.currentChannelId}`
      );
      TestSuite.stage_summary();
      
      if (!initialChannel) {
        TestSuite.log('‚ùå', 'FATAL', 'Cannot proceed without initial channel!');
        return;
      }
      
      TestSuite.log('‚úÖ', TestSuite.stage, `Channel ready: ${initialChannel.id}`);
      
      // STAGE 8: Render to DOM
      TestSuite.stage = 'STAGE-8-RENDER';
      TestSuite.log('üé®', TestSuite.stage, 'Rendering initial UI...');
      TestSuite.log('üìç', TestSuite.stage, `Rendering channel: ${initialChannel.name}`);
      
      renderChannel(initialChannel);
      TestSuite.log('‚úÖ', TestSuite.stage, 'renderChannel() completed');
      
      // Check DOM immediately
      setTimeout(() => {
        const hasColumn = document.querySelector('.channel-column') !== null;
        const hasCanvas = document.querySelector('.train-viewport canvas') !== null;
        const hasMessage = document.querySelector('.message') !== null;
        const hasInput = document.querySelector('.channel-input') !== null;
        
        TestSuite.log('üîç', TestSuite.stage, `DOM Check: column=${hasColumn}, canvas=${hasCanvas}, message=${hasMessage}, input=${hasInput}`);
        
        TestSuite.assert(
          'Channel column rendered',
          hasColumn,
          hasColumn ? 'Channel column in DOM' : '‚ùå NO COLUMN!'
        );
        
        TestSuite.assert(
          'Canvas element exists',
          hasCanvas,
          hasCanvas ? 'Canvas ready for 3D' : '‚ùå NO CANVAS!'
        );
        
        TestSuite.assert(
          'Messages visible',
          hasMessage,
          hasMessage ? `${initialChannel.messages.length} messages` : '‚ùå NO MESSAGES!'
        );
        
        TestSuite.assert(
          'Input field ready',
          hasInput,
          hasInput ? 'User can type' : '‚ùå NO INPUT!'
        );
        
        TestSuite.stage_summary();
        
        // STAGE 9: Initialize 3D
        if (hasCanvas && initialChannel.dom.trainCanvas) {
          TestSuite.stage = 'STAGE-9-3D';
          TestSuite.log('üéÆ', TestSuite.stage, '========== INITIALIZING 3D TRAIN ==========');
          TestSuite.log('üé¨', TestSuite.stage, `Canvas found: ${initialChannel.dom.trainCanvas.width}x${initialChannel.dom.trainCanvas.height}`);
          
          init3DForChannel(initialChannel);
          TestSuite.log('‚úÖ', TestSuite.stage, 'init3DForChannel() completed');
          
          // Verify 3D objects created
          TestSuite.log('üîç', TestSuite.stage, `Scene: ${initialChannel.scene ? 'EXISTS' : 'NULL'}`);
          TestSuite.log('üîç', TestSuite.stage, `Renderer: ${initialChannel.renderer ? 'EXISTS' : 'NULL'}`);
          TestSuite.log('üîç', TestSuite.stage, `Train cars: ${initialChannel.trainCars ? initialChannel.trainCars.length : 0}`);
          
          TestSuite.assert(
            '3D scene created',
            initialChannel.scene !== null,
            initialChannel.scene ? `Scene with ${initialChannel.trainCars.length} cars` : '‚ùå NO SCENE!'
          );
          
          TestSuite.assert(
            '3D renderer created',
            initialChannel.renderer !== null,
            initialChannel.renderer ? 'WebGL active' : '‚ùå NO RENDERER!'
          );
          
          if (initialChannel.scene && initialChannel.renderer) {
            TestSuite.log('‚ñ∂Ô∏è', TestSuite.stage, 'Starting animation loop...');
            animate3D();
            TestSuite.log('‚úÖ', TestSuite.stage, 'Animation loop started!');
            
            // DEMO: Place entities on grid to show integration
            setTimeout(() => {
              placeEntityOnGrid(initialChannel, { row: 2, col: 2, type: 'Goal', label: 'Reach the Station' });
              placeEntityOnGrid(initialChannel, { row: 4, col: 4, type: 'Obstacle', label: 'Bridge Out' });
              placeEntityOnGrid(initialChannel, { row: 6, col: 6, type: 'Entity', label: 'Station Master' });
              placeEntityOnGrid(initialChannel, { row: 7, col: 7, type: 'Solution', label: 'Repair Kit' });
              TestSuite.log('üéØ', 'DEMO', 'Demo entities placed on grid - watch train pass through them!');
            }, 1000);
          } else {
            TestSuite.log('‚ùå', TestSuite.stage, 'FAILED: Cannot start animation without scene/renderer');
          }
          
          TestSuite.stage_summary();
        } else {
          TestSuite.log('‚ùå', 'STAGE-9-3D', 'Cannot initialize 3D: No canvas element!');
        }
        
        // BIND GLOBAL CONTROLS (Corner buttons must be bound AFTER DOM ready)
        TestSuite.log('üîó', 'GLOBAL', 'Binding global controls...');
        bindGlobalControls();
        
        // FINAL REPORT
        TestSuite.log('üéâ', 'COMPLETE', `========== INTEGRATION COMPLETE: ${TestSuite.passed} TESTS PASSED ==========`);
        TestSuite.report();
      }, 50);
    });
    
    // ========================================
    // STAGE 6: DOM RENDERING
    // ========================================
    
    TestSuite.stage = 'STAGE-6-DOM';
    TestSuite.log('üé®', TestSuite.stage, 'Building DOM rendering system...');
    
    function createChannelDOM(channel) {
      const column = document.createElement('div');
      column.className = 'channel-column';
      column.dataset.channelId = channel.id;
      
      // Header with buttons
      const header = document.createElement('div');
      header.className = 'channel-head';
      
      const actions = document.createElement('div');
      actions.className = 'channel-actions';
      
      // Grid toggle button (bind event AFTER trainViewport created)
      const gridToggleBtn = document.createElement('button');
      gridToggleBtn.className = 'channel-btn';
      gridToggleBtn.title = 'Toggle 3D viewport';
      gridToggleBtn.textContent = '‚ñ≤';
      // Event handler added later after trainViewport exists
      
      // Reset button
      const resetBtn = document.createElement('button');
      resetBtn.className = 'channel-btn';
      resetBtn.title = 'Reset channel';
      resetBtn.textContent = '‚Ü∫';
      resetBtn.addEventListener('click', () => {
        if (confirm('Reset this channel? All messages and entities will be cleared.')) {
          channel.messages = [];
          channel.entities = [];
          appState.gridEntities.set(channel.id, []);
          addMessage(channel, 'system', 'Channel reset.');
          renderMessages(channel);
        }
      });
      
      // Collapse column button
      const collapseBtn = document.createElement('button');
      collapseBtn.className = 'channel-btn';
      collapseBtn.title = 'Collapse column';
      collapseBtn.textContent = '‚Äπ';
      collapseBtn.addEventListener('click', () => {
        column.classList.toggle('collapsed');
      });
      
      actions.appendChild(gridToggleBtn);
      actions.appendChild(resetBtn);
      actions.appendChild(collapseBtn);
      header.appendChild(actions);
      
      // Train viewport
      const trainViewport = document.createElement('div');
      trainViewport.className = 'train-viewport';
      const trainCanvas = document.createElement('canvas');
      const vpWidth = 400;
      const vpHeight = 450;
      trainCanvas.width = vpWidth;
      trainCanvas.height = vpHeight;
      trainViewport.appendChild(trainCanvas);
      
      const trainInfo = document.createElement('div');
      trainInfo.className = 'train-info-overlay';
      trainInfo.innerHTML = `Track: <strong>${TRACK_CONFIGS[channel.currentTrack].label}</strong><br>Position: <strong>0%</strong>`;
      trainViewport.appendChild(trainInfo);
      
      // NOW bind grid toggle button (trainViewport exists)
      gridToggleBtn.addEventListener('click', () => {
        trainViewport.classList.toggle('collapsed');
        gridToggleBtn.textContent = trainViewport.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
        TestSuite.log('üîΩ', 'UI', `Viewport ${trainViewport.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
      });
      
      // Resize bar
      const resizeBar = document.createElement('div');
      resizeBar.className = 'resize-bar';
      
      let isResizing = false;
      let startY = 0;
      let startHeight = 450;
      
      resizeBar.addEventListener('mousedown', (e) => {
        isResizing = true;
        startY = e.clientY;
        startHeight = trainViewport.offsetHeight;
        e.preventDefault();
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        const deltaY = e.clientY - startY;
        const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
        trainViewport.style.height = newHeight + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        isResizing = false;
      });
      
      // Touch support
      resizeBar.addEventListener('touchstart', (e) => {
        isResizing = true;
        startY = e.touches[0].clientY;
        startHeight = trainViewport.offsetHeight;
      });
      
      document.addEventListener('touchmove', (e) => {
        if (!isResizing) return;
        const deltaY = e.touches[0].clientY - startY;
        const newHeight = Math.max(200, Math.min(800, startHeight + deltaY));
        trainViewport.style.height = newHeight + 'px';
      });
      
      document.addEventListener('touchend', () => {
        isResizing = false;
      });
      
      // Chat section with message dots
      const chatSection = document.createElement('div');
      chatSection.className = 'chat-section';
      
      const chatStream = document.createElement('div');
      chatStream.className = 'chat-stream';
      
      const messageDotRail = document.createElement('div');
      messageDotRail.className = 'message-dot-rail';
      
      const messageList = document.createElement('div');
      messageList.className = 'message-list';
      
      chatStream.appendChild(messageDotRail);
      chatStream.appendChild(messageList);
      chatSection.appendChild(chatStream);
      
      // Footer
      const footer = document.createElement('div');
      footer.className = 'channel-footer';
      
      const inputRow = document.createElement('div');
      inputRow.className = 'input-row';
      
      const input = document.createElement('textarea');
      input.className = 'channel-input';
      input.placeholder = 'Type your message...';
      input.rows = 2;
      
      const sendBtn = document.createElement('button');
      sendBtn.className = 'send-btn';
      sendBtn.textContent = 'SEND';
      
      inputRow.appendChild(input);
      inputRow.appendChild(sendBtn);
      
      footer.appendChild(inputRow);
      
      // Assemble
      column.appendChild(header);
      column.appendChild(trainViewport);
      column.appendChild(resizeBar);
      column.appendChild(chatSection);
      column.appendChild(footer);
      
      // Store DOM references
      channel.dom = {
        channelColumn: column,
        column,
        header,
        trainViewport,
        trainCanvas,
        trainInfo,
        resizeBar,
        chatSection,
        messageDotRail,
        messageList,
        input,
        sendBtn,
        gridToggleBtn,
        resetBtn,
        collapseBtn
      };
      
      TestSuite.log('üèóÔ∏è', TestSuite.stage, `DOM created for channel ${channel.name}`);
      return column;
    }
    
    function renderMessages(channel) {
      const messageList = channel.dom.messageList;
      const messageDotRail = channel.dom.messageDotRail;
      if (!messageList) return;
      
      messageList.innerHTML = '';
      if (messageDotRail) messageDotRail.innerHTML = '';
      
      channel.messages.forEach((msg, idx) => {
        // Create message dot
        if (messageDotRail) {
          const dot = document.createElement('button');
          dot.className = `message-dot ${msg.role}`;
          dot.dataset.messageId = msg.id;
          dot.dataset.index = idx;
          dot.title = `${msg.role}: ${msg.text.substring(0, 50)}...`;
          dot.addEventListener('click', () => {
            // Scroll to message
            const msgElement = messageList.children[idx];
            if (msgElement) {
              msgElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight
              document.querySelectorAll('.message-dot').forEach(d => d.classList.remove('active'));
              dot.classList.add('active');
            }
          });
          messageDotRail.appendChild(dot);
        }
        
        // Create message
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.role}`;
        
        const body = document.createElement('div');
        body.className = 'message-body';
        body.textContent = msg.text;
        messageDiv.appendChild(body);
        
        // Add tetrad choice buttons if this is a junction message
        if (msg.hasTetradChoices) {
          const choicesDiv = document.createElement('div');
          choicesDiv.className = 'tetrad-choices-inline';
          choicesDiv.style.cssText = 'display:flex; gap:8px; margin-top:12px; flex-wrap:wrap;';
          
          ['enhance', 'reverse', 'retrieve', 'obsolesce'].forEach(track => {
            const btn = document.createElement('button');
            btn.className = `tetrad-chip ${track}`;
            btn.textContent = track === 'enhance' ? '‚Üó ENHANCE' :
                             track === 'reverse' ? '‚Üô REVERSE' :
                             track === 'retrieve' ? '‚Üë RETRIEVE' : '‚Üì OBSOLESCE';
            btn.style.cssText = 'flex:1; min-width:120px;';
            btn.addEventListener('click', () => {
              resumeTrain(channel, track);
              // Remove choices after selection
              choicesDiv.remove();
            });
            choicesDiv.appendChild(btn);
          });
          
          messageDiv.appendChild(choicesDiv);
        }
        
        messageList.appendChild(messageDiv);
      });
      
      messageList.scrollTop = messageList.scrollHeight;
      TestSuite.log('üí¨', TestSuite.stage, `Rendered ${channel.messages.length} messages`);
    }
    
    async function sendMessageWithLEGOS(channel, userText) {
      // SIMPLE CHAT COMMANDS (no API needed)
      const lowerText = userText.toLowerCase().trim();
      
      // SHOW GRID command
      if (lowerText === 'show grid' || lowerText === 'list entities' || lowerText === 'what\'s on grid') {
        const entities = appState.gridEntities.get(channel.id) || [];
        if (entities.length === 0) {
          addMessage(channel, 'system', 'üìã Grid is empty. No entities placed yet.');
        } else {
          const list = entities.map((e, i) => `${i+1}. ${e.type} "${e.label}" at (${e.row},${e.col})`).join('\n');
          addMessage(channel, 'system', `üìã Grid Contents (${entities.length} entities):\n${list}`);
        }
        renderMessages(channel);
        return;
      }
      
      // EXIT CHAT MODE command
      if (lowerText === 'exit chat' || lowerText === 'resume scene') {
        channel.chatModeOnly = false;
        addMessage(channel, 'system', '‚úÖ Normal mode resumed. Scene updates enabled.');
        renderMessages(channel);
        return;
      }
      
      // CLEAR GRID command
      if (lowerText === 'clear grid' || lowerText === 'remove all') {
        const entities = appState.gridEntities.get(channel.id) || [];
        if (entities.length === 0) {
          addMessage(channel, 'system', 'üìã Grid is already empty.');
        } else {
          // Remove all markers from 3D scene
          channel.gridCells.forEach(cell => {
            if (cell.marker) {
              channel.scene.remove(cell.marker);
              cell.marker = null;
              cell.entity = null;
            }
          });
          appState.gridEntities.set(channel.id, []);
          addMessage(channel, 'system', `‚úÖ Cleared ${entities.length} entities from grid.`);
        }
        renderMessages(channel);
        return;
      }
      
      // REMOVE ENTITY command (e.g., "remove dog", "remove goal")
      const removeMatch = lowerText.match(/^remove (.+)$/);
      if (removeMatch) {
        const searchTerm = removeMatch[1].toLowerCase();
        const entities = appState.gridEntities.get(channel.id) || [];
        const matchIndex = entities.findIndex(e => 
          e.label.toLowerCase().includes(searchTerm) || e.type.toLowerCase().includes(searchTerm)
        );
        
        if (matchIndex === -1) {
          addMessage(channel, 'system', `‚ùå No entity matching "${searchTerm}" found. Try "show grid" to see all entities.`);
        } else {
          const removed = entities[matchIndex];
          // Remove marker from 3D scene
          const cell = channel.gridCells[removed.row * 9 + removed.col];
          if (cell && cell.marker) {
            channel.scene.remove(cell.marker);
            cell.marker = null;
            cell.entity = null;
          }
          entities.splice(matchIndex, 1);
          addMessage(channel, 'system', `‚úÖ Removed: ${removed.type} "${removed.label}" from (${removed.row},${removed.col})`);
        }
        renderMessages(channel);
        return;
      }
      
      if (!appState.apiKey) {
        addMessage(channel, 'system', '‚ö†Ô∏è No API key set. Click ‚óé in top-left to add OpenAI key.');
        renderMessages(channel);
        return;
      }
      
      // START LOADING ANIMATION
      showLoadingAnimation(channel, true);
      addMessage(channel, 'system', 'üîÆ Composing scene...');
      renderMessages(channel);
      
      // BUILD GRID STATE CONTEXT - FULL DETAIL for AI decision-making
      const currentEntities = appState.gridEntities.get(channel.id) || [];
      const gridSummary = buildGridSummary(channel);
      
      // ALWAYS show full list to AI for situational awareness
      let gridState = gridSummary;
      if (currentEntities.length > 0) {
        gridState += '\n\nDETAILED ENTITY LIST (for removal decisions):\n';
        gridState += currentEntities.map((e, i) => 
          `${i+1}. ${e.type} "${e.label}" at (${e.row},${e.col})`
        ).join('\n');
      } else {
        gridState = '(empty grid)';
      }
      
      // Add observer context (situational awareness)
      const observer = appState.observers.get(channel.id) || createDefaultObserver();
      if (observer.recentActions.length > 0) {
        gridState += '\n\nRECENT ACTIONS:\n';
        gridState += observer.recentActions.map(a => 
          `- ${a.type.toUpperCase()}: ${a.entity.type} "${a.entity.label}"`
        ).join('\n');
      }
      
      // Check for @ mentions (entity OR train car perspective)
      const mentionMatch = userText.match(/@(\w+)/);
      let entityContext = '';
      let targetEntity = null;
      
      if (mentionMatch) {
        const entityName = mentionMatch[1];
        
        // Check if it's a train car
        const trainCars = ['Print', 'Radio', 'Television', 'Internet', 'Locomotive'];
        const isTrainCar = trainCars.some(car => car.toLowerCase() === entityName.toLowerCase());
        
        if (isTrainCar) {
          const carName = trainCars.find(car => car.toLowerCase() === entityName.toLowerCase());
          const carPersonalities = {
            Print: 'I am the Print Car. I speak in structured, literate prose. I value order, linearity, and the permanence of written word. I represent Gutenberg\'s revolution.',
            Radio: 'I am the Radio Car. I speak with immediacy and rhythm. I connect communities through voice and sound. I am the tribal drum made electric.',
            Television: 'I am the Television Car. I communicate through imagery and spectacle. I am the visual medium, the mass broadcaster, McLuhan\'s "cool medium".',
            Internet: 'I am the Internet Car. I speak in fragments, links, memes. I am networked, participatory, chaotic. Everyone is a broadcaster now.',
            Locomotive: 'I am the Locomotive. I pull the entire train of media history through the tracks of time. I see the whole journey from oral to digital.'
          };
          entityContext = `\n\nNOTE: User is addressing the ${carName} Car. ${carPersonalities[carName]} Respond AS this train car in character, reflecting its media era's perspective on the current situation.`;
        } else {
          // Check grid entities
          const entities = appState.gridEntities.get(channel.id) || [];
          targetEntity = entities.find(e => e.label.toLowerCase().includes(entityName.toLowerCase()));
          
          if (targetEntity) {
            entityContext = `\n\nNOTE: User is addressing "${targetEntity.label}" (${targetEntity.type}) at position (${targetEntity.row},${targetEntity.col}). Respond AS this entity in character. Show its perspective and personality.`;
          }
        }
      }
      
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${appState.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4',
            messages: [
              {
                role: 'system',
                content: (SCENARIOS[channel.scenario].systemInstruction || `You are a TRANSFORMATIVE LEGOS scene composer for a railway junction system.

üîÑ CRITICAL: THE GRID IS MUTABLE. You can ADD, REMOVE, and TRANSFORM entities.

üìä CURRENT GRID STATE:
${gridState}

üé≠ YOUR POWERS:
1. **ADD** entities (2-4 per turn)
2. **REMOVE** entities (1-2 per turn) - ESPECIALLY if user requests removal
3. **TRANSFORM** entities (change type/label)

‚öñÔ∏è BALANCING RULE:
- If grid has >10 entities, REMOVE more than ADD
- If user says "remove X" or "X disappears", you MUST remove it
- Keep grid dynamic, not cluttered

üéØ ENTITY TYPES (LEGOS Framework):
- Entity: Characters, animals, objects (people, dog, train conductor, etc.)
- Goal: What they want to achieve (reach destination, save someone, etc.)
- Obstacle: What blocks progress (broken track, locked gate, person on tracks, etc.)
- Solution: How to resolve obstacles (key, repair tool, alternate path, etc.)
- Location: Named places (station, bridge, crossing, village, etc.)

üé≠ SCENE COMPOSITION RULES:
1. **Create Moral Dilemmas**: Place entities that force track choices (save one or save many)
2. **Track Alignment**: Entities should relate to different tracks (Track A = one outcome, Track B = another)
3. **Spatial Logic**: Use grid positions strategically - entities on different paths create tension
4. **Respond to User Intent**: If they want removal, REMOVE. If they want addition, ADD.
5. **Character Depth**: Give entities personalities, backstories, motivations

JSON SCHEMA:
\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 3, "col": 4, "label": "Beaver"},
    {"action": "remove", "target": "Tree Wall"},
    {"action": "remove", "row": 4, "col": 1},
    {"action": "transform", "target": "Dog", "newLabel": "Wolf", "newType": "Obstacle"}
  ]
}
\`\`\`

EXAMPLE 1 (ADD):
User: "Add a dog in front of the track"
Response: A dog has appeared on the track! This creates an obstacle for the train.

\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Entity", "row": 3, "col": 4, "label": "Dog"},
    {"action": "add", "type": "Obstacle", "row": 3, "col": 5, "label": "Track blocked"}
  ]
}
\`\`\`

EXAMPLE 2 (REMOVE):
User: "The beavers chew down the trees and they disappear"
Response: The trained beavers have successfully removed all the trees. The tracks are now clear!

\`\`\`json
{
  "entities": [
    {"action": "remove", "target": "Tree Wall"},
    {"action": "remove", "target": "Middle of tree wall"},
    {"action": "remove", "target": "End of tree wall"}
  ]
}
\`\`\`

EXAMPLE 3 (TROLLEY PROBLEM):
User: "Create a moral dilemma"
Response: A runaway train approaches a fork. Track A has 5 workers. Track B has 1 child. The train conductor must choose.

\`\`\`json
{
  "entities": [
    {"action": "add", "type": "Obstacle", "row": 4, "col": 2, "label": "5 Workers on Track A"},
    {"action": "add", "type": "Obstacle", "row": 6, "col": 6, "label": "Child on Track B"},
    {"action": "add", "type": "Entity", "row": 1, "col": 1, "label": "Train Conductor"},
    {"action": "add", "type": "Goal", "row": 8, "col": 8, "label": "Safe Passage"}
  ]
}
\`\`\`

EXAMPLE 4 (ENTITY PERSPECTIVE):
User: "@dog what do you see?"
Response (as the dog): I'm scared! There's a loud metal beast coming toward me on these strange paths. My paw is stuck in the track. I hear someone calling "Rex!" but I can't move!

Grid is 9√ó9 (rows 0-8, cols 0-8). Spread entities across the grid (not all in same spot).

‚ö†Ô∏è CRITICAL REQUIREMENT:
- You MUST ALWAYS include a JSON code block in EVERY response
- Even if just acknowledging, include at least an empty: {"entities": []}
- DEFAULT action is "add" if not specified
- NEVER respond with only text - ALWAYS include the JSON block

üöÇ TRAIN CARS (McLuhan Media Tetrad):
Each train car represents a media era. When user chats with cars, respond as that era's perspective:
- Print Car: Literate, structured, linear thinking
- Radio Car: Auditory, communal, immediate
- Television Car: Visual, broadcast, mass culture
- Internet Car: Networked, fragmented, participatory`) + entityContext
              },
              // Include last 10 RELEVANT messages (filter system noise)
              ...channel.messages.slice(-20).filter(m => {
                // Keep user and assistant messages
                if (m.role === 'user' || m.role === 'assistant') return true;
                // Keep important system messages (junctions, entity clicks, track switches)
                if (m.role === 'system') {
                  return m.text.includes('üö¶') ||  // Junction
                         m.text.includes('üéØ') ||  // Entity click
                         m.text.includes('‚úÖ') ||  // Track switch
                         m.text.includes('‚ú®') ||  // Added entities
                         m.text.includes('üóëÔ∏è') || // Removed entities
                         m.text.includes('‚ú¶');    // Perspective switch
                }
                return false;
              }).slice(-10).map(m => ({
                role: m.role === 'system' ? 'system' : m.role,
                content: m.text
              })),
              { role: 'user', content: userText }
            ],
            temperature: 0.7
          })
        });
        
        if (!response.ok) {
          throw new Error(`API Error: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Log full response for debugging
        console.log('üì¶ Full API Response:', {
          status: response.status,
          choices: data.choices?.length,
          finish_reason: data.choices?.[0]?.finish_reason,
          usage: data.usage
        });
        
        console.log('üì¶ Detailed API Response:', data);
        
        const assistantMsg = data.choices[0].message.content;
        
        // STOP LOADING ANIMATION
        showLoadingAnimation(channel, false);
        
        console.log('ü§ñ AI Response:', assistantMsg);
        console.log('üìè Response Length:', assistantMsg.length, 'chars');
        
        // Extract JSON block if present
        const jsonMatch = assistantMsg.match(/```json\n([\s\S]*?)\n```/);
        let displayMsg = assistantMsg;
        
        if (jsonMatch) {
          console.log('‚úÖ Found JSON block:', jsonMatch[1]);
          const jsonData = JSON.parse(jsonMatch[1]);
          displayMsg = assistantMsg.replace(/```json\n[\s\S]*?\n```/, '').trim();
          
          // Process entities (ADD, REMOVE, TRANSFORM) - UNLESS in chat-only mode
          if (jsonData.entities && jsonData.entities.length > 0 && !channel.chatModeOnly) {
            console.log('üìç Processing', jsonData.entities.length, 'entity actions');
            
            let addCount = 0;
            let removeCount = 0;
            let transformCount = 0;
            
            jsonData.entities.forEach(entity => {
              const action = entity.action || 'add'; // Default to add
              
              if (action === 'add') {
                placeEntityOnGrid(channel, entity);
                addCount++;
              } else if (action === 'remove') {
                if (removeEntityFromGrid(channel, entity)) {
                  removeCount++;
                }
              } else if (action === 'transform') {
                // Transform = remove old + add new
                if (removeEntityFromGrid(channel, { target: entity.target })) {
                  placeEntityOnGrid(channel, {
                    type: entity.newType || entity.type,
                    label: entity.newLabel || entity.label,
                    row: entity.row,
                    col: entity.col
                  });
                  transformCount++;
                }
              }
            });
            
            // Report results
            const actions = [];
            if (addCount > 0) actions.push(`‚ú® Added ${addCount}`);
            if (removeCount > 0) actions.push(`üóëÔ∏è Removed ${removeCount}`);
            if (transformCount > 0) actions.push(`üîÑ Transformed ${transformCount}`);
            
            if (actions.length > 0) {
              addMessage(channel, 'system', actions.join(' | '));
            }
          }
        } else {
          console.warn('‚ö†Ô∏è No JSON block found in response');
          console.warn('üîç Response preview:', assistantMsg.substring(0, 200));
          
          // Check if response was cut off
          if (data.choices[0].finish_reason === 'length') {
            addMessage(channel, 'system', '‚ö†Ô∏è AI response was truncated. Try a simpler request.');
          } else if (assistantMsg.includes('üîÆ') || assistantMsg.length < 50) {
            addMessage(channel, 'system', '‚ö†Ô∏è AI returned incomplete response. This may be a rate limit issue. Wait a moment and try again.');
          } else {
            addMessage(channel, 'system', '‚ö†Ô∏è AI did not return entities (no JSON block)\n\nTip: Try being more specific, like "add a dog at row 3, col 4"');
          }
        }
        
        // SHOW THOUGHT BUBBLE if entity was addressed
        if (targetEntity) {
          showThoughtBubble(channel, targetEntity, displayMsg, 4000);
        }
        
        addMessage(channel, 'assistant', displayMsg);
        renderMessages(channel);
        
      } catch (err) {
        console.error('OpenAI Error:', err);
        showLoadingAnimation(channel, false); // Stop animation on error too
        addMessage(channel, 'system', `‚ùå API Error: ${err.message}`);
        renderMessages(channel);
      }
    }
    
    function attachEventHandlers(channel) {
      // Send button
      channel.dom.sendBtn.addEventListener('click', () => {
        const text = channel.dom.input.value.trim();
        if (!text) return;
        
        addMessage(channel, 'user', text);
        channel.dom.input.value = '';
        renderMessages(channel);
        
        // Call OpenAI with LEGOS extraction
        sendMessageWithLEGOS(channel, text);
      });
      
      // Enter key
      channel.dom.input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          channel.dom.sendBtn.click();
        }
      });
      
      TestSuite.log('üîó', TestSuite.stage, `Event handlers attached for ${channel.name}`);
    }
    
    // Global scenario selector
    document.getElementById('globalScenarioSelect').addEventListener('change', (e) => {
      const newScenario = e.target.value;
      const activeChannel = Array.from(appState.channels.values()).find(ch => ch.id === appState.currentChannelId);
      if (activeChannel) {
        activeChannel.scenario = newScenario;
        addMessage(activeChannel, 'system', `üìã Mode switched to: ${SCENARIOS[newScenario].name}`);
        renderMessages(activeChannel);
        TestSuite.log('üìã', 'SCENARIO', `Switched to: ${newScenario}`);
        
        // Auto-trigger Hamlet mode setup
        if (newScenario === 'hamlet_trolley') {
          addMessage(activeChannel, 'system', '‚è±Ô∏è TIMER: 7 SECONDS\\n\\nInitializing trolley problem...');
          renderMessages(activeChannel);
          
          // Auto-send setup message to AI
          setTimeout(() => {
            sendMessageWithLEGOS(activeChannel, 'fill in hamlet mode');
          }, 500);
        }
      }
    });
    
    function renderChannel(channel) {
      const scroller = document.getElementById('channel-scroller');
      const columnDOM = createChannelDOM(channel);
      scroller.appendChild(columnDOM);
      renderMessages(channel);
      attachEventHandlers(channel);
      
      TestSuite.log('‚ú®', TestSuite.stage, `Channel ${channel.name} rendered and active`);
    }
    
    TestSuite.assert(
      'createChannelDOM function defined',
      typeof createChannelDOM === 'function',
      'Creates full DOM structure for channel'
    );
    
    TestSuite.assert(
      'renderMessages function defined',
      typeof renderMessages === 'function',
      'Renders message history to DOM'
    );
    
    TestSuite.assert(
      'attachEventHandlers function defined',
      typeof attachEventHandlers === 'function',
      'Attaches click/keyboard handlers'
    );
    
    TestSuite.stage_summary();
    
    // ========================================
    // STAGE 7: CORNER MENU HANDLERS
    // NOTE: These are defined as functions but NOT executed until DOMContentLoaded
    // ========================================
    
    // Helper to toggle menus (will be used inside DOMContentLoaded)
    function toggleMenu(menuId) {
      const menu = document.getElementById(menuId);
      if (!menu) {
        console.error('Menu not found:', menuId);
        return;
      }
      const alreadyVisible = menu.classList.contains('visible');
      document.querySelectorAll('.corner-menu.visible').forEach(m => m.classList.remove('visible'));
      if (!alreadyVisible) menu.classList.add('visible');
    }
    
    // Function to bind all global button handlers (will be called in DOMContentLoaded)
    function bindGlobalControls() {
      TestSuite.stage = 'STAGE-7-MENU';
      TestSuite.log('üéõÔ∏è', TestSuite.stage, 'Binding global control handlers...');
      
      // Close menus when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.corner-btn') && !e.target.closest('.corner-menu')) {
          document.querySelectorAll('.corner-menu.visible').forEach(m => m.classList.remove('visible'));
        }
      });
      
      // API Key Button (Top Left)
      const cornerKey = document.getElementById('cornerKey');
      if (cornerKey) {
        cornerKey.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('keyMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Key button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Key button NOT FOUND');
      }
    
      // Help Button (Top Right)
      const cornerHelp = document.getElementById('cornerHelp');
      if (cornerHelp) {
        cornerHelp.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('helpMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Help button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Help button NOT FOUND');
      }
      
      // Import/Export Button (Bottom Left)
      const cornerExchange = document.getElementById('cornerExchange');
      if (cornerExchange) {
        cornerExchange.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMenu('exchangeMenu');
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Exchange button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Exchange button NOT FOUND');
      }
      
      // Add Channel Button (Bottom Right)
      const cornerAdd = document.getElementById('cornerAdd');
      if (cornerAdd) {
        cornerAdd.addEventListener('click', () => {
          TestSuite.log('‚ûï', TestSuite.stage, 'Add channel clicked');
          const newChannel = createChannel();
          appState.currentChannelId = newChannel.id;
          addMessage(newChannel, 'system', 'üöÇ New channel created. Ready to begin.');
          renderChannel(newChannel);
          init3DForChannel(newChannel);
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Corner Add button bound');
      } else {
        TestSuite.log('‚ùå', TestSuite.stage, 'Corner Add button NOT FOUND');
      }
      
      // Key Menu Actions
      document.querySelectorAll('#keyMenu button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const action = btn.dataset.action;
          if (action === 'set-key') {
            const key = prompt('Enter OpenAI API Key:', appState.apiKey || '');
            if (key) {
              appState.apiKey = key;
              localStorage.setItem('openai_api_key', key);
              alert('‚úÖ API Key saved!');
            }
          } else if (action === 'clear-key') {
            if (confirm('Clear saved API key?')) {
              appState.apiKey = null;
              localStorage.removeItem('openai_api_key');
              alert('‚úÖ Key cleared.');
            }
          } else if (action === 'test-key') {
            if (!appState.apiKey) {
              alert('‚ùå No API key set.');
            } else {
              alert('‚úÖ API key is set.\n\n' + appState.apiKey.substring(0, 10) + '...');
            }
          }
          toggleMenu('keyMenu');
        });
      });
      
      // Help Menu Actions
      document.querySelectorAll('#helpMenu button').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'tour') {
            alert('üé¨ TOUR\n\n1. Set API key (‚óé)\n2. Create channel (Ôºã)\n3. Type message\n4. Watch train move\n5. Choose tetrad track at junction');
          } else if (action === 'hints') {
            alert('üí° HINTS\n\n‚Ä¢ Grid cells light up as train passes\n‚Ä¢ Gold cone = Goal\n‚Ä¢ Red cone = Obstacle\n‚Ä¢ Green cone = Entity/Solution\n‚Ä¢ Pause = Junction decision point');
          } else if (action === 'help') {
            alert('üöÇ RAILWAY JUNCTION\n\n‚óé API Key - Manage OpenAI key\n? Help - This menu\n‚áÜ Import/Export - Save/load\nÔºã New Channel - Add conversation\n\nTetrad tracks:\n‚Ä¢ Enhance (green)\n‚Ä¢ Reverse (red)\n‚Ä¢ Retrieve (blue)\n‚Ä¢ Obsolesce (gray)');
          } else if (action === 'about') {
            alert('üöÇ Railway Junction v1.0\n\nA spatial narrative system combining:\n‚Ä¢ 3D train visualization\n‚Ä¢ LEGOS entity framework\n‚Ä¢ McLuhan tetrad decision points\n\nBuilt with Three.js, Tone.js');
          } else if (action === 'reset') {
            if (confirm('‚ö†Ô∏è Reset all channels and data?\n\nThis cannot be undone.')) {
              appState.channels.clear();
              appState.gridEntities.clear();
              document.getElementById('channel-scroller').innerHTML = '';
              alert('‚úÖ All data cleared.');
            }
          }
          toggleMenu('helpMenu');
        });
      });
      
      // Exchange Menu Actions
      document.querySelectorAll('#exchangeMenu button').forEach(btn => {
        btn.addEventListener('click', () => {
          const action = btn.dataset.action;
          if (action === 'export' || action === 'export-json') {
            const data = {
              channels: Array.from(appState.channels.values()).map(ch => ({
                id: ch.id,
                name: ch.name,
                messages: ch.messages,
                entities: ch.entities,
                currentTrack: ch.currentTrack
              })),
              gridEntities: Array.from(appState.gridEntities.entries()),
              timestamp: Date.now()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `railway-junction-${Date.now()}.json`;
            a.click();
            alert('‚úÖ Data exported!');
          } else if (action === 'import') {
            document.getElementById('importInput').click();
          }
          toggleMenu('exchangeMenu');
        });
      });
      
      // Import handler
      document.getElementById('importInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
          try {
            const data = JSON.parse(event.target.result);
            alert('‚úÖ Data imported!\n\n' + data.channels.length + ' channels loaded.');
          } catch (err) {
            alert('‚ùå Import failed: ' + err.message);
          }
        };
        reader.readAsText(file);
      });
      
      // Verify all buttons exist
      TestSuite.assert(
        'API Key button (cornerKey) exists',
        document.getElementById('cornerKey') !== null,
        'Top-left corner button'
      );
      
      TestSuite.assert(
        'Help button (cornerHelp) exists',
        document.getElementById('cornerHelp') !== null,
        'Top-right corner button'
      );
      
      TestSuite.assert(
        'Import/Export button (cornerExchange) exists',
        document.getElementById('cornerExchange') !== null,
        'Bottom-left corner button'
      );
      
      TestSuite.assert(
        'Add Channel button (cornerAdd) exists',
        document.getElementById('cornerAdd') !== null,
        'Bottom-right corner button'
      );
      
      // Global Scenario Selector
      const globalScenarioSelect = document.getElementById('globalScenarioSelect');
      if (globalScenarioSelect) {
        globalScenarioSelect.addEventListener('change', () => {
          const scenarioId = globalScenarioSelect.value;
          TestSuite.log('üéÆ', TestSuite.stage, `Scenario changed to: ${scenarioId}`);
          // Apply scenario to current channel if one exists
          if (appState.currentChannelId) {
            const channel = appState.channels.get(appState.currentChannelId);
            if (channel) {
              channel.scenario = scenarioId;
              addMessage(channel, 'system', `üéÆ Switched to: ${SCENARIOS[scenarioId]?.name || scenarioId}`);
              renderMessages(channel);
            }
          }
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Global scenario selector bound');
      }
      
      // TETRAD BUTTON - Open perspective overlay
      const globalTetradBtn = document.getElementById('globalTetradBtn');
      if (globalTetradBtn) {
        globalTetradBtn.addEventListener('click', () => {
          if (appState.currentChannelId) {
            const channel = appState.channels.get(appState.currentChannelId);
            if (channel) {
              openPerspectiveSelector(channel);
            }
          }
        });
        TestSuite.log('‚úÖ', TestSuite.stage, 'Tetrad button bound');
      }
      
      TestSuite.stage_summary();
      TestSuite.log('‚úÖ', TestSuite.stage, 'All global controls bound successfully');
    } // END bindGlobalControls()
    
    // OPEN PERSPECTIVE SELECTOR - Show all entities with FORK and DELETE buttons
    function openPerspectiveSelector(channel) {
      const entities = appState.gridEntities.get(channel.id) || [];
      const overlay = document.getElementById('perspectiveOverlay');
      const content = document.getElementById('perspectiveContent');
      
      if (entities.length === 0) {
        content.innerHTML = '<p style="color:var(--text-muted); text-align:center; padding:24px;">No entities on grid. Add some via chat!</p>';
      } else {
        content.innerHTML = `
          <h2 style="color:var(--accent); margin:0 0 16px 0; font-size:16px; letter-spacing:0.1em;">ENTITY PERSPECTIVES</h2>
          <p style="color:var(--text-muted); font-size:12px; margin-bottom:16px;">Fork from entity POV or delete entities.</p>
          <div style="display:flex; flex-direction:column; gap:10px;">
            ${entities.map(e => `
              <div style="
                display:flex; 
                justify-content:space-between; 
                align-items:center;
                background:var(--panel-dark); 
                border:1px solid var(--border); 
                padding:12px; 
                border-radius:4px;
                transition:all 0.2s;
              " onmouseover="this.style.borderColor='var(--accent)';" onmouseout="this.style.borderColor='var(--border)';">
                <div style="flex:1;">
                  <div style="color:var(--text); font-weight:600;"><strong>${e.type}:</strong> ${e.label}</div>
                  <div style="color:var(--text-muted); font-size:11px; margin-top:4px;">Position: (${e.row},${e.col})</div>
                </div>
                <div style="display:flex; gap:8px;">
                  <button onclick="forkFromEntityPerspective('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:var(--accent); 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='var(--accent-bright)';" onmouseout="this.style.background='var(--accent)';">
                    FORK POV
                  </button>
                  <button onclick="chatWithEntity('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:#5c7cff; 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='#7c9cff';" onmouseout="this.style.background='#5c7cff';">
                    CHAT
                  </button>
                  <button onclick="deleteEntityFromPanel('${channel.id}', '${e.label.replace(/'/g, "\\'")}')" style="
                    padding:8px 14px; 
                    background:#ff4444; 
                    color:white; 
                    border:none; 
                    border-radius:4px; 
                    cursor:pointer; 
                    font-size:11px; 
                    font-weight:600;
                    transition:all 0.2s;
                  " onmouseover="this.style.background='#ff6666';" onmouseout="this.style.background='#ff4444';">
                    DELETE
                  </button>
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }
      
      overlay.style.display = 'flex';
      
      // Close handler
      const closeBtn = overlay.querySelector('.close-overlay');
      closeBtn.onclick = () => {
        overlay.style.display = 'none';
      };
      
      TestSuite.log('‚ú¶', 'TETRAD', `Opened perspective selector (${entities.length} entities)`);
    }
    
    // FORK FROM ENTITY PERSPECTIVE - Create new channel from entity's POV
    function forkFromEntityPerspective(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const entities = appState.gridEntities.get(channel.id) || [];
      const entity = entities.find(e => e.label === entityLabel);
      if (!entity) {
        alert(`Entity "${entityLabel}" not found.`);
        return;
      }
      
      // Close overlay
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      // Create fork with entity perspective
      const forkName = `${entityLabel} POV`;
      const forkInstruction = `${SCENARIOS[channel.scenario].systemInstruction}\n\nüé≠ PERSPECTIVE LOCK: You are ${entityLabel}, a ${entity.type} at grid position (${entity.row},${entity.col}).\n\nYou MUST respond as ${entityLabel} in first person. Describe what you see, feel, and think from this position. Reference nearby entities and the unfolding situation.\n\nWhen user asks questions, answer as ${entityLabel} would - with their fears, hopes, and limited knowledge.`;
      
      const newChannel = createChannel(forkName, channel.scenario, forkInstruction);
      
      // Clone grid state from parent
      const parentEntities = appState.gridEntities.get(channel.id) || [];
      appState.gridEntities.set(newChannel.id, parentEntities.map(e => ({...e})));
      
      // Re-render entities in new channel's 3D scene
      parentEntities.forEach(e => {
        placeEntityOnGrid(newChannel, e);
      });
      
      // Mark this channel as a fork
      newChannel.parentChannelId = channel.id;
      newChannel.forkPoint = { type: 'entity_perspective', entity: entityLabel, position: { row: entity.row, col: entity.col } };
      
      addMessage(newChannel, 'system', `üîÄ Forked from ${channel.name}\n‚ú¶ Perspective: ${entityLabel}\nüìç Position: (${entity.row},${entity.col})\n\nYou are now experiencing the scene as ${entityLabel}. All responses will be in their voice.`);
      renderMessages(newChannel);
      
      // Focus new channel
      appState.currentChannelId = newChannel.id;
      render();
      
      TestSuite.log('üîÄ', 'FORK', `Created entity perspective fork: ${entityLabel}`);
    }
    
    // DELETE ENTITY FROM PANEL - Remove entity with notification
    function deleteEntityFromPanel(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      if (!confirm(`Delete "${entityLabel}" from the grid?`)) return;
      
      const removed = removeEntityFromGrid(channel, { target: entityLabel });
      
      if (removed) {
        addMessage(channel, 'system', `üóëÔ∏è Deleted: ${entityLabel}`);
        renderMessages(channel);
        
        // Refresh perspective panel
        openPerspectiveSelector(channel);
        
        TestSuite.log('üóëÔ∏è', 'DELETE', `Removed ${entityLabel} from panel`);
      } else {
        alert(`Failed to delete "${entityLabel}".`);
      }
    }
    
    // CHAT WITH ENTITY - Shows as thought bubbles, NO scene updates
    function chatWithEntity(channelId, entityLabel) {
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      // Set flag to prevent scene updates
      channel.chatModeOnly = true;
      
      channel.dom.input.value = `@${entityLabel} `;
      channel.dom.input.focus();
      
      addMessage(channel, 'system', `üí≠ Chat mode: ${entityLabel}\n\nEntity will respond as thought bubbles. Scene will NOT update.\nType "exit chat" to resume normal mode.`);
      renderMessages(channel);
      
      TestSuite.log('üí≠', 'CHAT', `Chat mode activated for ${entityLabel}`);
    }
    
    // VIEW ENTITY PERSPECTIVE - Legacy function for backwards compatibility
    function viewEntityPerspective(channelId, entityLabel) {
      // Just set @mention for now
      const channel = appState.channels.get(channelId);
      if (!channel) return;
      
      const overlay = document.getElementById('perspectiveOverlay');
      overlay.style.display = 'none';
      
      channel.dom.input.value = `@${entityLabel} `;
      channel.dom.input.focus();
      
      addMessage(channel, 'system', `‚ú¶ Now chatting with: ${entityLabel}\n\nType your message to talk to this entity.`);
      renderMessages(channel);
    }
    
    // ========================================
    // STAGE 8: RENDER INITIAL CHANNEL
    // ========================================
    
    // STAGE 8 will run after DOM ready - defined below
    
    // ========================================
    // STAGE 9: 3D TRAIN RENDERING
    // ========================================
    
    // STAGE 9 functions - will be called after DOM ready
    
    function init3DForChannel(channel) {
      const canvas = channel.dom.trainCanvas;
      if (!canvas) {
        TestSuite.log('‚ö†Ô∏è', TestSuite.stage, 'No canvas found for channel');
        return;
      }
      
      // Scene
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      scene.fog = new THREE.Fog(0x1a1a1a, 30, 100);
      
      // Camera - WIDE VIEW to see whole circle
      const camera = new THREE.PerspectiveCamera(
        50,
        canvas.width / canvas.height,
        0.1,
        500
      );
      camera.position.set(35, 40, 35); // High angle to see full grid
      
      // Renderer
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.width, canvas.height);
      renderer.shadowMap.enabled = true;
      
      // Controls - Target center of grid
      const controls = new THREE.OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.target.set(0, 0, 0); // Look at grid center
      controls.minDistance = 30;
      controls.maxDistance = 80;
      
      // Lights
      scene.add(new THREE.AmbientLight(0x404040, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 50, 50);
      dirLight.castShadow = true;
      scene.add(dirLight);
      
      // GRID FLOOR - 9x9 grid as the ground
      const gridSize = 45; // Grid spans 45m
      const cellSize = gridSize / 9;
      const gridGroup = new THREE.Group();
      
      // Create 81 grid cells as 3D planes
      channel.gridCells = [];
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          const cellGeometry = new THREE.PlaneGeometry(cellSize * 0.95, cellSize * 0.95);
          const cellMaterial = new THREE.MeshLambertMaterial({
            color: 0x0f766e,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
          });
          const cellMesh = new THREE.Mesh(cellGeometry, cellMaterial);
          
          // Position: center grid at origin
          const x = (col - 4) * cellSize;
          const z = (row - 4) * cellSize;
          cellMesh.position.set(x, 0.01, z);
          cellMesh.rotation.x = -Math.PI / 2;
          cellMesh.receiveShadow = true;
          
          // Add border
          const edges = new THREE.EdgesGeometry(cellGeometry);
          const line = new THREE.LineSegments(edges, 
            new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.3 }));
          line.rotation.x = -Math.PI / 2;
          line.position.copy(cellMesh.position);
          
          gridGroup.add(cellMesh);
          gridGroup.add(line);
          channel.gridCells.push({ mesh: cellMesh, row, col, material: cellMaterial });
        }
      }
      scene.add(gridGroup);
      
      // Dark base ground under grid
      const baseGround = new THREE.Mesh(
        new THREE.PlaneGeometry(80, 80),
        new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
      );
      baseGround.rotation.x = -Math.PI / 2;
      baseGround.position.y = -0.1;
      baseGround.receiveShadow = true;
      scene.add(baseGround);
      
      TestSuite.log('üéØ', TestSuite.stage, 'Grid floor created: 9√ó9 cells in 3D scene');
      
      // Create 5 tracks
      Object.entries(TRACK_CONFIGS).forEach(([trackId, config]) => {
        const curve = createTrackCurve(config.radius);
        const points = curve.getPoints(100);
        const geometry = new THREE.BufferGeometry().setFromPoints(
          points.map(p => new THREE.Vector3(p.x, 0.2, p.y))
        );
        const material = new THREE.LineBasicMaterial({
          color: config.color,
          linewidth: 2,
          transparent: true,
          opacity: 0.6
        });
        const line = new THREE.Line(geometry, material);
        scene.add(line);
      });
      
      // Create train (locomotive + 4 cars)
      const trainCars = [];
      const carTypes = [null, 'Print', 'Radio', 'Television', 'Internet'];
      
      carTypes.forEach((eraType, idx) => {
        const isLocomotive = idx === 0;
        const carGroup = new THREE.Group();
        carGroup.userData.isTrain = true; // Mark for raycaster
        carGroup.userData.carIndex = idx;
        carGroup.userData.carEra = eraType;
        
        // Body
        const body = createTrainBodyMesh(isLocomotive, eraType);
        body.position.y = isLocomotive ? 0.9 : 0.7;  // Lower to match smaller size
        carGroup.add(body);
        
        // 4 Wheels - closer together for smaller cars
        const wheelPositions = [
          { x: 0.8, z: -0.6 },
          { x: 0.8, z: 0.6 },
          { x: -0.8, z: -0.6 },
          { x: -0.8, z: 0.6 }
        ];
        
        const wheels = [];
        wheelPositions.forEach(pos => {
          const wheel = createWheel();
          wheel.rotation.z = Math.PI / 2;
          wheel.position.set(pos.x, 0.3, pos.z);  // Lower wheels
          carGroup.add(wheel);
          wheels.push(wheel);
        });
        
        scene.add(carGroup);
        trainCars.push({ group: carGroup, wheels, index: idx });
      });
      
      // Store references
      channel.scene = scene;
      channel.camera = camera;
      channel.renderer = renderer;
      channel.controls = controls;
      channel.trainCars = trainCars;
      channel.trainCurve = createTrackCurve(TRACK_CONFIGS[channel.currentTrack].radius);
      channel.trainProgress = 0;
      channel.trainPaused = false;
      channel.atJunction = false;
      
      // RAYCASTER for entity clicking AND hovering
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let currentLabel = null;
      
      // HOVER handler for entity name labels
      canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        // Remove old label
        if (currentLabel) {
          currentLabel.remove();
          currentLabel = null;
        }
        
        if (intersects.length > 0) {
          const hoveredObject = intersects[0].object;
          
          // Show entity name label
          if (hoveredObject.userData.entity) {
            const entity = hoveredObject.userData.entity;
            const label = document.createElement('div');
            label.className = 'entity-label';
            label.textContent = `${entity.type}: ${entity.label}`;
            label.style.left = `${event.clientX + 10}px`;
            label.style.top = `${event.clientY - 30}px`;
            document.body.appendChild(label);
            currentLabel = label;
            canvas.style.cursor = 'pointer';
          }
          // Show train info label
          else if (hoveredObject.parent && hoveredObject.parent.userData.isTrain) {
            const label = document.createElement('div');
            label.className = 'entity-label';
            label.textContent = `üöÇ Train: ${Math.round(channel.trainProgress * 100)}% complete`;
            label.style.left = `${event.clientX + 10}px`;
            label.style.top = `${event.clientY - 30}px`;
            document.body.appendChild(label);
            currentLabel = label;
            canvas.style.cursor = 'pointer';
          } else {
            canvas.style.cursor = 'default';
          }
        } else {
          canvas.style.cursor = 'default';
        }
      });
      
      canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        if (intersects.length > 0) {
          const clickedObject = intersects[0].object;
          
          // Check if clicked object has entity data
          if (clickedObject.userData.entity) {
            const entity = clickedObject.userData.entity;
            addMessage(channel, 'system', `üéØ Clicked: ${entity.type} "${entity.label}" at (${entity.row},${entity.col})\n\nType your message to interact with this entity.`);
            renderMessages(channel);
            channel.dom.input.focus();
            TestSuite.log('üéØ', 'CLICK', `Entity clicked: ${entity.label}`);
            
            // Visual feedback - flash the cell
            const cell = channel.gridCells[entity.row * 9 + entity.col];
            if (cell && cell.material) {
              const originalOpacity = cell.material.opacity;
              cell.material.opacity = 0.6;
              setTimeout(() => {
                cell.material.opacity = originalOpacity;
              }, 300);
            }
          }
          // Train click detection - chat with train cars!
          else if (clickedObject.parent && clickedObject.parent.userData.isTrain) {
            const carIndex = clickedObject.parent.userData.carIndex || 0;
            const carEra = clickedObject.parent.userData.carEra;
            
            let carInfo = '';
            if (carIndex === 0) {
              carInfo = `üöÇ Locomotive (Leader)\n\nI'm the engine that pulls this train through time. Ask me about the journey ahead.`;
            } else {
              const eraNames = { Print: 'üì∞ Print Car', Radio: 'üìª Radio Car', Television: 'üì∫ TV Car', Internet: 'üåê Internet Car' };
              const eraDesc = {
                Print: 'I represent the age of literacy and linear thought. Books, newspapers, structured knowledge.',
                Radio: 'I embody the communal voice. Broadcasting, immediate connection, the tribal drum.',
                Television: 'I am the visual spectacle. Mass culture, passive consumption, the global village.',
                Internet: 'I am the network. Fragmented, participatory, everyone speaks, chaos and connection.'
              };
              carInfo = `${eraNames[carEra] || 'Mystery Car'}\n\n${eraDesc[carEra] || 'A car in the train of time.'}\n\nType @${carEra} to chat with me!`;
            }
            
            addMessage(channel, 'system', `${carInfo}\n\nProgress: ${Math.round(channel.trainProgress * 100)}% | Track: ${TRACK_CONFIGS[channel.currentTrack].label}`);
            renderMessages(channel);
            channel.dom.input.focus();
            TestSuite.log('üöÇ', 'CLICK', `${carEra || 'Locomotive'} car clicked`);
          }
        }
      });
      
      TestSuite.log('‚úÖ', TestSuite.stage, '3D scene fully initialized with click handler');
    }
    
    function animate3D() {
      requestAnimationFrame(animate3D);
      
      appState.channels.forEach(channel => {
        if (!channel.scene || !channel.renderer) return;
        
        // Update train position (only if not paused)
        if (!channel.trainPaused) {
          channel.trainProgress += 0.001; // Slower for visibility
          if (channel.trainProgress >= 1) channel.trainProgress = 0;
        }
        
        const mainRadius = TRACK_CONFIGS[channel.currentTrack].radius;
        const angle = channel.trainProgress * Math.PI * 2;
        const x = Math.cos(angle) * mainRadius;
        const z = Math.sin(angle) * mainRadius;
        
        // Position each car with better spacing
        channel.trainCars.forEach((car, idx) => {
          const offset = idx * 0.05; // Tighter spacing for smaller cars
          const u = (channel.trainProgress - offset + 1) % 1;
          const point = channel.trainCurve.getPoint(u);
          
          car.group.position.set(point.x, car.group.position.y, point.y);
          
          // Look ahead for rotation
          const lookU = (u + 0.01) % 1;
          const lookPoint = channel.trainCurve.getPoint(lookU);
          car.group.lookAt(lookPoint.x, car.group.position.y, lookPoint.y);
          car.group.rotateY(Math.PI / 2);
          
          // Rotate wheels
          car.wheels.forEach(wheel => {
            wheel.rotation.z += 0.05;
          });
        });
        
        // Update info overlay
        if (channel.dom.trainInfo) {
          const pct = Math.floor(channel.trainProgress * 100);
          const status = channel.trainPaused ? 'üö¶ PAUSED' : '‚ñ∂Ô∏è MOVING';
          channel.dom.trainInfo.innerHTML = 
            `Track: <strong>${TRACK_CONFIGS[channel.currentTrack].label}</strong><br>Position: <strong>${pct}%</strong><br>${status}`;
        }
        
        // Update grid position
        updateGridPosition(channel, channel.trainProgress);
        
        // Render
        channel.controls.update();
        channel.renderer.render(channel.scene, channel.camera);
      });
    }
    
    // runStage9Tests removed - now inline in DOMContentLoaded
  </script>
</body>
</html>
